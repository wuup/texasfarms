<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Texas Farms - The Game</title>
    <style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
    font-family: 'Segoe UI', system-ui, sans-serif;
    background: #1a2e1a;
    overflow: hidden;
    touch-action: none;
}
#game-container {
    width: 100vw;
    height: 100vh;
    position: relative;
}
canvas {
    display: block;
    image-rendering: pixelated;
}
/* HUD Overlay */
#hud {
    position: absolute;
    top: 10px;
    left: 10px;
    right: 10px;
    display: flex;
    justify-content: space-between;
    pointer-events: none;
    z-index: 100;
}
.hud-panel {
    background: rgba(0,0,0,0.7);
    color: #f7f4ed;
    padding: 10px 16px;
    border-radius: 8px;
    font-size: 14px;
    pointer-events: auto;
}
.hud-panel h3 {
    font-size: 12px;
    color: #b87333;
    margin-bottom: 4px;
    text-transform: uppercase;
}
#money-display { font-size: 20px; font-weight: bold; color: #22c55e; }
#time-display { font-weight: 600; }

/* Dialog Box */
#dialog {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.9);
    color: #f7f4ed;
    padding: 16px 24px;
    border-radius: 12px;
    border: 2px solid #b87333;
    max-width: 600px;
    width: 90%;
    display: none;
    z-index: 200;
}
#dialog.show { display: block; }
#dialog-text { margin-bottom: 12px; line-height: 1.5; }
#dialog-options {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
}
#dialog-options button {
    background: #2d4a3e;
    border: 1px solid #b87333;
    color: #f7f4ed;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
}
#dialog-options button:hover { background: #3d5a4e; }
#dialog-options button.primary { background: #b87333; }

/* Inventory Bar */
#inventory-bar {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 4px;
    background: rgba(0,0,0,0.8);
    padding: 8px;
    border-radius: 8px;
    border: 2px solid #b87333;
    z-index: 100;
}
.inv-slot {
    width: 48px;
    height: 48px;
    background: rgba(50,50,50,0.8);
    border: 2px solid #555;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    cursor: pointer;
    position: relative;
    transition: all 0.1s;
}
.inv-slot:hover { background: rgba(80,80,80,0.8); }
.inv-slot.selected { border-color: #ffcc00; box-shadow: 0 0 10px rgba(255,204,0,0.5); }
.inv-slot .count {
    position: absolute;
    bottom: 2px;
    right: 4px;
    font-size: 12px;
    color: #fff;
    text-shadow: 1px 1px 2px #000;
}
.inv-slot .key {
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: 10px;
    color: #888;
}

/* Energy Bar */
#energy-bar {
    position: absolute;
    top: 80px;
    right: 10px;
    background: rgba(0,0,0,0.7);
    padding: 8px;
    border-radius: 8px;
    z-index: 100;
}
#energy-bar label { color: #aaa; font-size: 12px; }
#energy-fill {
    width: 100px;
    height: 12px;
    background: #333;
    border-radius: 6px;
    overflow: hidden;
    margin-top: 4px;
}
#energy-fill-inner {
    height: 100%;
    background: linear-gradient(90deg, #22c55e, #4ade80);
    transition: width 0.3s;
}

/* Instructions */
#instructions {
    position: absolute;
    bottom: 90px;
    right: 10px;
    background: rgba(0,0,0,0.6);
    color: #aaa;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 11px;
    line-height: 1.4;
}

/* Title Screen */
#title-screen {
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, #1a2e1a 0%, #2d4a3e 100%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 500;
}
#title-screen h1 {
    font-size: 3rem;
    margin-bottom: 0.5rem;
}
#title-screen h2 {
    font-size: 2rem;
    color: #f7f4ed;
    margin-bottom: 0.25rem;
}
#title-screen p {
    color: #b87333;
    font-style: italic;
    margin-bottom: 2rem;
}
#title-screen button {
    background: #b87333;
    border: none;
    color: white;
    padding: 16px 48px;
    font-size: 1.2rem;
    border-radius: 8px;
    cursor: pointer;
    margin: 8px;
}
#title-screen button:hover { background: #d4915c; }

/* Toast */
#toast {
    position: absolute;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: #f7f4ed;
    padding: 12px 24px;
    border-radius: 8px;
    display: none;
    z-index: 300;
}
#toast.show { display: block; animation: fadeInOut 3s forwards; }
@keyframes fadeInOut {
    0%, 80% { opacity: 1; }
    100% { opacity: 0; }
}
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="game-canvas"></canvas>

    <div id="hud">
        <div class="hud-panel">
            <h3>Farmer</h3>
            <div id="money-display">$500</div>
        </div>
        <div class="hud-panel">
            <h3>Time</h3>
            <div id="time-display">Day 1, Spring Y1</div>
            <div id="weather-display" style="font-size: 18px; margin-top: 4px;">‚òÄÔ∏è</div>
            <div id="music-toggle" onclick="Game.toggleMusic()" style="font-size: 16px; margin-top: 4px; cursor: pointer;" title="Press M to toggle">üîá</div>
        </div>
        <div class="hud-panel">
            <h3>Farm</h3>
            <div id="animal-count">0 animals</div>
        </div>
    </div>

    <div id="dialog">
        <div id="dialog-text"></div>
        <div id="dialog-options"></div>
    </div>

    <div id="toast"></div>

    <div id="inventory-bar">
        <div class="inv-slot selected" onclick="Game.selectSlot(0)"><span class="key">1</span></div>
        <div class="inv-slot" onclick="Game.selectSlot(1)"><span class="key">2</span></div>
        <div class="inv-slot" onclick="Game.selectSlot(2)"><span class="key">3</span></div>
        <div class="inv-slot" onclick="Game.selectSlot(3)"><span class="key">4</span></div>
        <div class="inv-slot" onclick="Game.selectSlot(4)"><span class="key">5</span></div>
        <div class="inv-slot" onclick="Game.selectSlot(5)"><span class="key">6</span></div>
        <div class="inv-slot" onclick="Game.selectSlot(6)"><span class="key">7</span></div>
        <div class="inv-slot" onclick="Game.selectSlot(7)"><span class="key">8</span></div>
    </div>

    <div id="energy-bar">
        <label>Energy</label>
        <div id="energy-fill"><div id="energy-fill-inner" style="width: 100%"></div></div>
    </div>

    <div id="instructions">
        WASD: Move | Click/E: Interact<br>
        1-8: Select | C: Craft | U: Upgrade | K: Skills | H: Help
    </div>

    <div id="title-screen">
        <h1>üåæ</h1>
        <h2>Texas Farms</h2>
        <p>A Vermont Farming Adventure</p>
        <div id="title-buttons">
            <button onclick="Game.start()">New Game</button>
            <button id="continue-btn" onclick="Game.continueGame()" style="display:none">Continue</button>
        </div>
    </div>
</div>

<script>
// ==========================================
// TEXAS FARMS - THE GAME v2.0.0
// Artisan goods crafting system!
// ==========================================

const TILE_SIZE = 48;
const WORLD_WIDTH = 30;
const WORLD_HEIGHT = 20;

// ==========================================
// WORLD MAP - Tile Types
// ==========================================
const TILES = {
    GRASS: 0,
    DIRT_PATH: 1,
    WATER: 2,
    FENCE: 3,
    BARN_FLOOR: 4,
    BARN_WALL: 5,
    TREE: 6,
    FLOWERS: 7,
    HAY: 8,
    TROUGH: 9,
    DOOR: 10,
    MARKET_STALL: 11,
    HOUSE_WALL: 12,
    HOUSE_FLOOR: 13,
    TILLED: 14,       // Hoed soil ready for planting
    WATERED: 15,      // Watered tilled soil
    STONE: 16,        // Rocks to break
    WOOD: 17,         // Stumps to chop
    SHIPPING_BIN: 18, // Sell items overnight
    SPRINKLER: 19,    // Auto-waters nearby crops
    BERRY_BUSH: 20,   // Forageable berries
};

// Colors for each tile
const TILE_COLORS = {
    [TILES.GRASS]: '#4a7c59',
    [TILES.DIRT_PATH]: '#8b7355',
    [TILES.WATER]: '#4a90d9',
    [TILES.FENCE]: '#8b6914',
    [TILES.BARN_FLOOR]: '#a0522d',
    [TILES.BARN_WALL]: '#8b4513',
    [TILES.TREE]: '#2d5a27',
    [TILES.FLOWERS]: '#4a7c59',
    [TILES.HAY]: '#daa520',
    [TILES.TROUGH]: '#696969',
    [TILES.DOOR]: '#654321',
    [TILES.MARKET_STALL]: '#8b4513',
    [TILES.HOUSE_WALL]: '#deb887',
    [TILES.HOUSE_FLOOR]: '#d2b48c',
    [TILES.TILLED]: '#6b4423',
    [TILES.WATERED]: '#4a3520',
    [TILES.STONE]: '#666',
    [TILES.WOOD]: '#5a4020',
    [TILES.SHIPPING_BIN]: '#8b4513',
    [TILES.SPRINKLER]: '#4a7c59',
    [TILES.BERRY_BUSH]: '#2d6a2d',
};

// Which tiles block movement
const SOLID_TILES = [TILES.WATER, TILES.FENCE, TILES.BARN_WALL, TILES.TREE, TILES.HOUSE_WALL, TILES.STONE, TILES.WOOD];

// ==========================================
// ITEMS & TOOLS
// ==========================================
const ITEMS = {
    HOE: { id: 'hoe', name: 'Hoe', emoji: 'üî®', type: 'tool', desc: 'Till soil for planting' },
    WATERING_CAN: { id: 'watering_can', name: 'Watering Can', emoji: 'ü™£', type: 'tool', desc: 'Water your crops' },
    PICKAXE: { id: 'pickaxe', name: 'Pickaxe', emoji: '‚õèÔ∏è', type: 'tool', desc: 'Break rocks' },
    AXE: { id: 'axe', name: 'Axe', emoji: 'ü™ì', type: 'tool', desc: 'Chop wood' },
    FISHING_ROD: { id: 'fishing_rod', name: 'Fishing Rod', emoji: 'üé£', type: 'tool', desc: 'Catch fish in water' },
    // Spring crops
    TURNIP_SEEDS: { id: 'turnip_seeds', name: 'Turnip Seeds', emoji: 'üå±', type: 'seed', crop: 'turnip', growDays: 4, price: 20, seasons: ['Spring', 'Fall'] },
    POTATO_SEEDS: { id: 'potato_seeds', name: 'Potato Seeds', emoji: 'ü•î', type: 'seed', crop: 'potato', growDays: 6, price: 40, seasons: ['Spring'] },
    CARROT_SEEDS: { id: 'carrot_seeds', name: 'Carrot Seeds', emoji: 'ü•ï', type: 'seed', crop: 'carrot', growDays: 6, price: 35, seasons: ['Spring', 'Fall'] },
    // Summer crops
    TOMATO_SEEDS: { id: 'tomato_seeds', name: 'Tomato Seeds', emoji: 'üçÖ', type: 'seed', crop: 'tomato', growDays: 8, price: 50, seasons: ['Summer'] },
    CORN_SEEDS: { id: 'corn_seeds', name: 'Corn Seeds', emoji: 'üåΩ', type: 'seed', crop: 'corn', growDays: 10, price: 75, seasons: ['Summer', 'Fall'] },
    PEPPER_SEEDS: { id: 'pepper_seeds', name: 'Pepper Seeds', emoji: 'üå∂Ô∏è', type: 'seed', crop: 'pepper', growDays: 7, price: 45, seasons: ['Summer'] },
    // Fall crops
    PUMPKIN_SEEDS: { id: 'pumpkin_seeds', name: 'Pumpkin Seeds', emoji: 'üéÉ', type: 'seed', crop: 'pumpkin', growDays: 12, price: 100, seasons: ['Fall'] },
    // Harvested crops
    TURNIP: { id: 'turnip', name: 'Turnip', emoji: 'ü•¨', type: 'crop', sellPrice: 60 },
    POTATO: { id: 'potato', name: 'Potato', emoji: 'ü•î', type: 'crop', sellPrice: 120 },
    CARROT: { id: 'carrot', name: 'Carrot', emoji: 'ü•ï', type: 'crop', sellPrice: 100 },
    TOMATO: { id: 'tomato', name: 'Tomato', emoji: 'üçÖ', type: 'crop', sellPrice: 150 },
    CORN: { id: 'corn', name: 'Corn', emoji: 'üåΩ', type: 'crop', sellPrice: 200 },
    PEPPER: { id: 'pepper', name: 'Pepper', emoji: 'üå∂Ô∏è', type: 'crop', sellPrice: 140 },
    PUMPKIN: { id: 'pumpkin', name: 'Pumpkin', emoji: 'üéÉ', type: 'crop', sellPrice: 350 },
    STONE: { id: 'stone', name: 'Stone', emoji: 'ü™®', type: 'resource', sellPrice: 5 },
    WOOD: { id: 'wood', name: 'Wood', emoji: 'ü™µ', type: 'resource', sellPrice: 10 },
    // Fish
    BASS: { id: 'bass', name: 'Bass', emoji: 'üêü', type: 'fish', sellPrice: 40, rarity: 0.4 },
    TROUT: { id: 'trout', name: 'Trout', emoji: 'üê†', type: 'fish', sellPrice: 80, rarity: 0.3 },
    CATFISH: { id: 'catfish', name: 'Catfish', emoji: 'üê°', type: 'fish', sellPrice: 120, rarity: 0.2 },
    GOLDEN_FISH: { id: 'golden_fish', name: 'Golden Fish', emoji: '‚ú®üêü', type: 'fish', sellPrice: 500, rarity: 0.05 },
    OLD_BOOT: { id: 'old_boot', name: 'Old Boot', emoji: 'üë¢', type: 'junk', sellPrice: 1, rarity: 0.05 },
    // Foraging
    WILD_BERRIES: { id: 'wild_berries', name: 'Wild Berries', emoji: 'ü´ê', type: 'forage', sellPrice: 25 },
    MUSHROOM: { id: 'mushroom', name: 'Mushroom', emoji: 'üçÑ', type: 'forage', sellPrice: 40 },
    WILD_HONEY: { id: 'wild_honey', name: 'Wild Honey', emoji: 'üçØ', type: 'forage', sellPrice: 100 },
    // Animal products
    EGG: { id: 'egg', name: 'Egg', emoji: 'ü•ö', type: 'product', sellPrice: 30 },
    WOOL: { id: 'wool', name: 'Wool', emoji: 'üß∂', type: 'product', sellPrice: 50 },
    TRUFFLE: { id: 'truffle', name: 'Truffle', emoji: 'üçÑ', type: 'product', sellPrice: 250 },
    FEATHER: { id: 'feather', name: 'Goose Feather', emoji: 'ü™∂', type: 'product', sellPrice: 40 },
    // Craftables
    SPRINKLER: { id: 'sprinkler', name: 'Sprinkler', emoji: 'üíß', type: 'placeable', desc: 'Auto-waters 8 tiles around it' },
    SCARECROW: { id: 'scarecrow', name: 'Scarecrow', emoji: 'üéÉ', type: 'placeable', desc: 'Protects crops from crows' },
    // Artisan goods (crafted from animal products)
    PILLOW: { id: 'pillow', name: 'Goose Pillow', emoji: 'üõèÔ∏è', type: 'artisan', sellPrice: 150 },
    WOOL_BLANKET: { id: 'wool_blanket', name: 'Wool Blanket', emoji: 'üß£', type: 'artisan', sellPrice: 200 },
    TRUFFLE_OIL: { id: 'truffle_oil', name: 'Truffle Oil', emoji: 'ü´í', type: 'artisan', sellPrice: 600 },
    MAYONNAISE: { id: 'mayonnaise', name: 'Mayonnaise', emoji: 'ü•´', type: 'artisan', sellPrice: 100 },
};

// Crafting recipes
const RECIPES = {
    sprinkler: { result: ITEMS.SPRINKLER, ingredients: { stone: 5, wood: 3 } },
    scarecrow: { result: ITEMS.SCARECROW, ingredients: { wood: 10, stone: 2 } },
    // Artisan goods - turn animal products into valuable items
    pillow: { result: ITEMS.PILLOW, ingredients: { feather: 5 } },
    wool_blanket: { result: ITEMS.WOOL_BLANKET, ingredients: { wool: 4 } },
    truffle_oil: { result: ITEMS.TRUFFLE_OIL, ingredients: { truffle: 1 } },
    mayonnaise: { result: ITEMS.MAYONNAISE, ingredients: { egg: 3 } },
};

// Tool upgrade tiers
const TOOL_TIERS = {
    0: { name: 'Basic', prefix: '', energyMult: 1.0, yieldMult: 1.0, color: '#888' },
    1: { name: 'Copper', prefix: 'üü§', energyMult: 0.85, yieldMult: 1.15, color: '#b87333' },
    2: { name: 'Iron', prefix: '‚ö™', energyMult: 0.70, yieldMult: 1.30, color: '#a8a8a8' },
    3: { name: 'Gold', prefix: 'üü°', energyMult: 0.50, yieldMult: 1.50, color: '#ffd700' },
};

// Tool upgrade costs
const TOOL_UPGRADE_COSTS = {
    1: { money: 500, stone: 10, wood: 5 },   // Basic -> Copper
    2: { money: 1500, stone: 25, wood: 15 }, // Copper -> Iron
    3: { money: 5000, stone: 50, wood: 30 }, // Iron -> Gold
};

// Crop growth stages
const CROP_STAGES = {
    turnip: ['üå±', 'üåø', 'ü•¨', 'ü•¨'],
    potato: ['üå±', 'üåø', 'ü•î', 'ü•î'],
    carrot: ['üå±', 'üåø', 'ü•ï', 'ü•ï'],
    tomato: ['üå±', 'üåø', 'ü™¥', 'üçÖ'],
    corn: ['üå±', 'üåø', 'üåæ', 'üåΩ'],
    pepper: ['üå±', 'üåø', 'ü™¥', 'üå∂Ô∏è'],
    pumpkin: ['üå±', 'üåø', 'ü™¥', 'üéÉ'],
};

// ==========================================
// AUDIO - Web Audio API sounds
// ==========================================
const Audio = {
    ctx: null,
    init() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    },
    play(type) {
        if (!this.ctx) this.init();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);

        const now = this.ctx.currentTime;
        gain.gain.setValueAtTime(0.1, now);

        switch(type) {
            case 'hoe':
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
            case 'water':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
                break;
            case 'plant':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
            case 'harvest':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(523, now);
                gain.gain.setValueAtTime(0.15, now);
                osc.frequency.setValueAtTime(659, now + 0.1);
                osc.frequency.setValueAtTime(784, now + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
                break;
            case 'pickup':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
                break;
            case 'error':
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
            case 'sell':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.setValueAtTime(800, now + 0.1);
                osc.frequency.setValueAtTime(1000, now + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
                osc.start(now);
                osc.stop(now + 0.25);
                break;
            case 'cast':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
                break;
            case 'bite':
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.08, now);
                osc.frequency.setValueAtTime(1000, now + 0.05);
                osc.frequency.setValueAtTime(800, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now);
                osc.stop(now + 0.15);
                break;
            case 'catch':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.setValueAtTime(600, now + 0.1);
                osc.frequency.setValueAtTime(800, now + 0.2);
                osc.frequency.setValueAtTime(1200, now + 0.3);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
                break;
            case 'splash':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
                break;
            case 'thunder':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(80, now);
                osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
                break;
            case 'achievement':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(523, now);
                gain.gain.setValueAtTime(0.12, now);
                osc.frequency.setValueAtTime(659, now + 0.15);
                osc.frequency.setValueAtTime(784, now + 0.3);
                osc.frequency.setValueAtTime(1047, now + 0.45);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
                break;
        }
    },

    // Background music system
    musicEnabled: false,
    musicGain: null,
    musicOscillators: [],
    musicInterval: null,
    currentChord: 0,

    // Chord progressions for ambient farm music (frequencies in Hz)
    chords: [
        [261.63, 329.63, 392.00], // C major
        [293.66, 369.99, 440.00], // D minor
        [329.63, 392.00, 493.88], // E minor
        [349.23, 440.00, 523.25], // F major
        [392.00, 493.88, 587.33], // G major
        [293.66, 369.99, 440.00], // D minor
        [329.63, 392.00, 493.88], // E minor
        [261.63, 329.63, 392.00], // C major
    ],

    startMusic() {
        if (this.musicEnabled) return;
        if (!this.ctx) this.init();

        this.musicEnabled = true;
        this.musicGain = this.ctx.createGain();
        this.musicGain.connect(this.ctx.destination);
        this.musicGain.gain.setValueAtTime(0.03, this.ctx.currentTime);

        this.playChord();
        this.musicInterval = setInterval(() => this.playChord(), 2000);
    },

    stopMusic() {
        if (!this.musicEnabled) return;
        this.musicEnabled = false;

        if (this.musicInterval) {
            clearInterval(this.musicInterval);
            this.musicInterval = null;
        }

        // Fade out and stop oscillators
        this.musicOscillators.forEach(osc => {
            try { osc.stop(); } catch(e) {}
        });
        this.musicOscillators = [];
    },

    playChord() {
        if (!this.musicEnabled || !this.ctx) return;

        const chord = this.chords[this.currentChord];
        this.currentChord = (this.currentChord + 1) % this.chords.length;

        // Clean up old oscillators
        this.musicOscillators.forEach(osc => {
            try { osc.stop(); } catch(e) {}
        });
        this.musicOscillators = [];

        const now = this.ctx.currentTime;

        // Play each note in the chord
        chord.forEach((freq, i) => {
            const osc = this.ctx.createOscillator();
            const noteGain = this.ctx.createGain();

            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, now);

            // Gentle envelope
            noteGain.gain.setValueAtTime(0, now);
            noteGain.gain.linearRampToValueAtTime(0.8, now + 0.3);
            noteGain.gain.linearRampToValueAtTime(0.5, now + 1.5);
            noteGain.gain.linearRampToValueAtTime(0, now + 2);

            osc.connect(noteGain);
            noteGain.connect(this.musicGain);

            osc.start(now);
            osc.stop(now + 2.1);

            this.musicOscillators.push(osc);
        });

        // Add a bass note (octave down from root)
        const bassOsc = this.ctx.createOscillator();
        const bassGain = this.ctx.createGain();
        bassOsc.type = 'sine';
        bassOsc.frequency.setValueAtTime(chord[0] / 2, now);
        bassGain.gain.setValueAtTime(0, now);
        bassGain.gain.linearRampToValueAtTime(0.6, now + 0.2);
        bassGain.gain.linearRampToValueAtTime(0.3, now + 1);
        bassGain.gain.linearRampToValueAtTime(0, now + 2);
        bassOsc.connect(bassGain);
        bassGain.connect(this.musicGain);
        bassOsc.start(now);
        bassOsc.stop(now + 2.1);
        this.musicOscillators.push(bassOsc);
    },

    toggleMusic() {
        if (this.musicEnabled) {
            this.stopMusic();
            return false;
        } else {
            this.startMusic();
            return true;
        }
    }
};

// Generate the world map
function generateWorld() {
    const map = [];
    for (let y = 0; y < WORLD_HEIGHT; y++) {
        const row = [];
        for (let x = 0; x < WORLD_WIDTH; x++) {
            row.push(TILES.GRASS);
        }
        map.push(row);
    }

    // Add dirt path from left to right
    for (let x = 0; x < WORLD_WIDTH; x++) {
        map[10][x] = TILES.DIRT_PATH;
        map[11][x] = TILES.DIRT_PATH;
    }
    // Vertical path
    for (let y = 5; y < 15; y++) {
        map[y][15] = TILES.DIRT_PATH;
        map[y][16] = TILES.DIRT_PATH;
    }

    // Add pond
    for (let y = 2; y < 5; y++) {
        for (let x = 2; x < 6; x++) {
            map[y][x] = TILES.WATER;
        }
    }

    // Add trees around edges
    for (let x = 0; x < WORLD_WIDTH; x++) {
        if (Math.random() < 0.4) map[0][x] = TILES.TREE;
        if (Math.random() < 0.4) map[WORLD_HEIGHT-1][x] = TILES.TREE;
    }
    for (let y = 0; y < WORLD_HEIGHT; y++) {
        if (Math.random() < 0.5) map[y][0] = TILES.TREE;
        if (Math.random() < 0.5) map[y][WORLD_WIDTH-1] = TILES.TREE;
    }

    // Add barn (pig barn)
    for (let y = 3; y < 8; y++) {
        for (let x = 20; x < 26; x++) {
            if (y === 3 || y === 7 || x === 20 || x === 25) {
                map[y][x] = TILES.BARN_WALL;
            } else {
                map[y][x] = TILES.BARN_FLOOR;
            }
        }
    }
    map[7][22] = TILES.DOOR; // Barn door
    map[7][23] = TILES.DOOR;

    // Add pig pasture fencing
    for (let x = 19; x < 27; x++) {
        map[9][x] = TILES.FENCE;
        map[14][x] = TILES.FENCE;
    }
    for (let y = 9; y < 15; y++) {
        map[y][19] = TILES.FENCE;
        map[y][26] = TILES.FENCE;
    }
    map[11][19] = TILES.GRASS; // Gate

    // Feed trough in pasture
    map[12][22] = TILES.TROUGH;
    map[12][23] = TILES.TROUGH;

    // Farmhouse
    for (let y = 3; y < 7; y++) {
        for (let x = 8; x < 13; x++) {
            if (y === 3 || y === 6 || x === 8 || x === 12) {
                map[y][x] = TILES.HOUSE_WALL;
            } else {
                map[y][x] = TILES.HOUSE_FLOOR;
            }
        }
    }
    map[6][10] = TILES.DOOR; // House door

    // Market stall at bottom
    for (let x = 10; x < 14; x++) {
        map[16][x] = TILES.MARKET_STALL;
    }

    // Shipping bin near house
    map[7][13] = TILES.SHIPPING_BIN;

    // Berry bushes in the wild areas
    const berrySpots = [{x:1, y:8}, {x:28, y:3}, {x:27, y:15}, {x:3, y:17}];
    berrySpots.forEach(pos => {
        if (map[pos.y][pos.x] === TILES.GRASS) {
            map[pos.y][pos.x] = TILES.BERRY_BUSH;
        }
    });

    // Farm plot area (left side, for crops)
    // Just mark it with dirt path border to show the planting area
    for (let x = 2; x < 8; x++) {
        map[6][x] = TILES.DIRT_PATH;
        map[12][x] = TILES.DIRT_PATH;
    }
    for (let y = 6; y < 13; y++) {
        map[y][2] = TILES.DIRT_PATH;
        map[y][7] = TILES.DIRT_PATH;
    }

    // Add some rocks and stumps to clear
    const resourcePositions = [
        {x: 14, y: 3, type: TILES.STONE},
        {x: 16, y: 5, type: TILES.STONE},
        {x: 12, y: 14, type: TILES.WOOD},
        {x: 17, y: 16, type: TILES.WOOD},
        {x: 8, y: 15, type: TILES.STONE},
        {x: 5, y: 14, type: TILES.WOOD},
    ];
    resourcePositions.forEach(r => {
        if (map[r.y][r.x] === TILES.GRASS) {
            map[r.y][r.x] = r.type;
        }
    });

    // Random flowers
    for (let y = 0; y < WORLD_HEIGHT; y++) {
        for (let x = 0; x < WORLD_WIDTH; x++) {
            if (map[y][x] === TILES.GRASS && Math.random() < 0.05) {
                map[y][x] = TILES.FLOWERS;
            }
        }
    }

    return map;
}

// ==========================================
// NPCs
// ==========================================
const NPC_DATA = {
    mayor: {
        name: 'Mayor Bob',
        sprite: 'üë¥',
        dialog: [
            "Howdy neighbor! Welcome to Texas Farms!",
            "Plant crops, raise animals, and make this land flourish!",
            "Come see me if you need any advice.",
        ],
        gifts: { turnip: "Oh, a turnip! My favorite. Thank you!" }
    },
    shopkeeper: {
        name: 'Sally',
        sprite: 'üë©‚Äçüåæ',
        dialog: [
            "Welcome to my shop! I sell seeds and buy produce.",
            "Turnips grow quick - great for beginners!",
            "Tomatoes take longer but sell for more!",
        ],
        gifts: { corn: "Corn! I can make some great cornbread with this!" }
    },
    wanderer: {
        name: 'Old Pete',
        sprite: 'üßì',
        dialog: [
            "Back in my day, we farmed without all these fancy tools...",
            "*mumbles about the weather*",
            "Have you checked the pond? Sometimes I see fish jumping...",
            "The barn door's always open for shelter from storms.",
        ],
        gifts: { carrot: "A carrot? Don't mind if I do!" }
    }
};

class NPC {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.data = NPC_DATA[type];
        this.dialogIndex = 0;
        this.wanderTimer = 0;
        this.wanderDir = { x: 0, y: 0 };
        this.homeX = x;
        this.homeY = y;
        this.lastTalked = -999;
    }

    get sprite() { return this.data.sprite; }
    get name() { return this.data.name; }

    update(world, day) {
        // Only wanderer moves around
        if (this.type === 'wanderer') {
            this.wanderTimer--;
            if (this.wanderTimer <= 0) {
                this.wanderTimer = 90 + Math.random() * 180;
                if (Math.random() < 0.3) {
                    this.wanderDir = { x: 0, y: 0 };
                } else {
                    const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                    this.wanderDir = dirs[Math.floor(Math.random() * dirs.length)];
                }
            }

            if (this.wanderDir.x !== 0 || this.wanderDir.y !== 0) {
                const newX = this.x + this.wanderDir.x * 0.8;
                const newY = this.y + this.wanderDir.y * 0.8;

                // Stay near home
                const distFromHome = Math.abs(newX - this.homeX) + Math.abs(newY - this.homeY);
                if (distFromHome < TILE_SIZE * 6) {
                    const tileX = Math.floor(newX / TILE_SIZE);
                    const tileY = Math.floor(newY / TILE_SIZE);

                    if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
                        const tile = world[tileY][tileX];
                        if (!SOLID_TILES.includes(tile)) {
                            this.x = newX;
                            this.y = newY;
                        }
                    }
                }
            }
        }
    }

    draw(ctx, camera) {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(screenX + TILE_SIZE/2, screenY + TILE_SIZE - 5, 15, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        // Sprite
        ctx.font = `${TILE_SIZE - 8}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.sprite, screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);

        // Name tag
        ctx.font = '12px sans-serif';
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeText(this.name, screenX + TILE_SIZE/2, screenY - 5);
        ctx.fillText(this.name, screenX + TILE_SIZE/2, screenY - 5);
    }

    getDialog(day) {
        // Different dialog if talked to recently
        if (day - this.lastTalked < 1) {
            return "We already talked today! Come back tomorrow.";
        }
        this.lastTalked = day;
        const dialog = this.data.dialog[this.dialogIndex];
        this.dialogIndex = (this.dialogIndex + 1) % this.data.dialog.length;
        return dialog;
    }
}

// ==========================================
// ENTITIES
// ==========================================

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.targetX = x;
        this.targetY = y;
        this.speed = 4;
        this.direction = 'down';
        this.moving = false;
        this.sprite = 'üë®‚Äçüåæ';
    }

    update(keys, world, entities) {
        let dx = 0, dy = 0;

        if (keys.up) { dy = -1; this.direction = 'up'; }
        if (keys.down) { dy = 1; this.direction = 'down'; }
        if (keys.left) { dx = -1; this.direction = 'left'; }
        if (keys.right) { dx = 1; this.direction = 'right'; }

        if (dx !== 0 || dy !== 0) {
            this.moving = true;
            const newX = this.x + dx * this.speed;
            const newY = this.y + dy * this.speed;

            // Check collision with world
            const tileX = Math.floor(newX / TILE_SIZE);
            const tileY = Math.floor(newY / TILE_SIZE);

            if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
                const tile = world[tileY][tileX];
                if (!SOLID_TILES.includes(tile)) {
                    this.x = newX;
                    this.y = newY;
                }
            }

            // Keep in bounds
            this.x = Math.max(0, Math.min(this.x, (WORLD_WIDTH - 1) * TILE_SIZE));
            this.y = Math.max(0, Math.min(this.y, (WORLD_HEIGHT - 1) * TILE_SIZE));
        } else {
            this.moving = false;
        }
    }

    draw(ctx, camera) {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;

        // Draw shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(screenX + TILE_SIZE/2, screenY + TILE_SIZE - 5, 15, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        // Draw player emoji
        ctx.font = `${TILE_SIZE - 8}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.sprite, screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
    }

    getInteractionPoint() {
        const offsets = {
            up: { x: 0, y: -TILE_SIZE },
            down: { x: 0, y: TILE_SIZE },
            left: { x: -TILE_SIZE, y: 0 },
            right: { x: TILE_SIZE, y: 0 }
        };
        const offset = offsets[this.direction];
        return {
            x: this.x + offset.x,
            y: this.y + offset.y
        };
    }
}

class Animal {
    constructor(x, y, type) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.x = x;
        this.y = y;
        this.type = type;
        this.age = 0;
        this.health = 100;
        this.happiness = 80;
        this.hunger = 0;
        this.weight = type === 'pig' ? 50 : (type === 'chicken' ? 2 : (type === 'goose' ? 8 : 0.5));
        this.name = this.generateName();
        this.wanderTimer = 0;
        this.wanderDir = { x: 0, y: 0 };
        this.genetics = {
            quality: 0.5 + Math.random() * 0.4,
            growth: 0.6 + Math.random() * 0.4,
        };
        this.productCooldown = 0; // Days until next product
        this.hasProduct = false; // If ready to collect
    }

    generateName() {
        const pigNames = ['Wilbur', 'Babe', 'Hamlet', 'Porky', 'Truffle', 'Rosie', 'Chester', 'Penny'];
        const rabbitNames = ['Thumper', 'Flopsy', 'Cotton', 'Peter', 'Hazel', 'Clover'];
        const chickenNames = ['Clucky', 'Henrietta', 'Pecky', 'Goldie', 'Sunny', 'Daisy', 'Nugget', 'Feathers'];
        const gooseNames = ['Honkers', 'Gander', 'Lucy', 'Toulouse', 'Grey', 'Waddles', 'Goosifer', 'Gigi'];
        if (this.type === 'pig') return pigNames[Math.floor(Math.random() * pigNames.length)];
        if (this.type === 'chicken') return chickenNames[Math.floor(Math.random() * chickenNames.length)];
        if (this.type === 'goose') return gooseNames[Math.floor(Math.random() * gooseNames.length)];
        return rabbitNames[Math.floor(Math.random() * rabbitNames.length)];
    }

    get sprite() {
        if (this.type === 'pig') {
            if (this.age < 60) return 'üê∑';
            return this.hasProduct ? 'üêñ‚ú®' : 'üêñ';
        }
        if (this.type === 'chicken') {
            if (this.age < 14) return 'üê§';
            return this.hasProduct ? 'üêî‚ú®' : 'üêî';
        }
        if (this.type === 'goose') {
            if (this.age < 30) return 'üê£';
            return this.hasProduct ? 'ü¶¢‚ú®' : 'ü¶¢';
        }
        return this.hasProduct ? 'üê∞‚ú®' : 'üê∞';
    }

    get maturityAge() {
        if (this.type === 'pig') return 180;
        if (this.type === 'chicken') return 21; // 3 weeks to maturity
        if (this.type === 'goose') return 100; // ~14 weeks to maturity
        return 90; // Rabbits
    }

    get value() {
        if (this.type === 'pig') return Math.round(this.weight * 3 * this.genetics.quality);
        if (this.type === 'chicken') return Math.round(20 * this.genetics.quality);
        if (this.type === 'goose') return Math.round(this.weight * 6 * this.genetics.quality);
        return Math.round(this.weight * 8 * this.genetics.quality); // Rabbits
    }

    get canProduce() {
        return this.age >= this.maturityAge &&
               this.hunger < 50 &&
               this.happiness > 30;
    }

    // Generate product if ready
    checkProduct() {
        if (!this.canProduce) {
            this.hasProduct = false;
            return null;
        }

        if (this.productCooldown > 0) {
            this.productCooldown--;
            return null;
        }

        if (this.hasProduct) {
            return null; // Already has uncollected product
        }

        // Set product ready based on animal type
        if (this.type === 'chicken') {
            this.hasProduct = true;
            this.productCooldown = 1; // Produce egg every day
            return ITEMS.EGG;
        }
        if (this.type === 'rabbit' && this.age >= 120) {
            // Rabbits produce wool less frequently
            if (Math.random() < 0.3) {
                this.hasProduct = true;
                this.productCooldown = 3;
                return ITEMS.WOOL;
            }
        }
        if (this.type === 'pig' && this.happiness > 70) {
            // Happy pigs occasionally find truffles
            if (Math.random() < 0.1) {
                this.hasProduct = true;
                this.productCooldown = 5;
                return ITEMS.TRUFFLE;
            }
        }
        if (this.type === 'goose') {
            // Geese produce feathers regularly
            if (Math.random() < 0.5) {
                this.hasProduct = true;
                this.productCooldown = 2;
                return ITEMS.FEATHER;
            }
        }
        return null;
    }

    collectProduct() {
        if (!this.hasProduct) return null;
        this.hasProduct = false;
        if (this.type === 'chicken') return ITEMS.EGG;
        if (this.type === 'rabbit') return ITEMS.WOOL;
        if (this.type === 'pig') return ITEMS.TRUFFLE;
        if (this.type === 'goose') return ITEMS.FEATHER;
        return null;
    }

    update(world) {
        // Random wandering
        this.wanderTimer--;
        if (this.wanderTimer <= 0) {
            this.wanderTimer = 60 + Math.random() * 120;
            if (Math.random() < 0.5) {
                this.wanderDir = { x: 0, y: 0 };
            } else {
                const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
                this.wanderDir = dirs[Math.floor(Math.random() * dirs.length)];
            }
        }

        if (this.wanderDir.x !== 0 || this.wanderDir.y !== 0) {
            const newX = this.x + this.wanderDir.x * 1;
            const newY = this.y + this.wanderDir.y * 1;

            const tileX = Math.floor(newX / TILE_SIZE);
            const tileY = Math.floor(newY / TILE_SIZE);

            if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
                const tile = world[tileY][tileX];
                if (!SOLID_TILES.includes(tile) && tile !== TILES.WATER) {
                    this.x = newX;
                    this.y = newY;
                } else {
                    this.wanderDir = { x: 0, y: 0 };
                }
            }
        }

        // Keep in pasture area (rough bounds)
        this.x = Math.max(20 * TILE_SIZE, Math.min(this.x, 25 * TILE_SIZE));
        this.y = Math.max(10 * TILE_SIZE, Math.min(this.y, 13 * TILE_SIZE));
    }

    draw(ctx, camera) {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(screenX + TILE_SIZE/2, screenY + TILE_SIZE - 8, 12, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Sprite
        ctx.font = `${TILE_SIZE - 12}px serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.sprite, screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);

        // Hunger indicator
        if (this.hunger > 50) {
            ctx.font = '16px serif';
            ctx.fillText('üí≠', screenX + TILE_SIZE - 5, screenY + 10);
        }
    }

    feed() {
        this.hunger = 0;
        this.happiness = Math.min(100, this.happiness + 10);
    }

    advanceDay() {
        this.age++;
        this.hunger += 20;

        // Weight gain if not hungry
        if (this.hunger < 50) {
            const gain = this.type === 'pig' ? 1.5 : 0.15;
            this.weight += gain * this.genetics.growth;
        }

        // Health effects
        if (this.hunger > 80) {
            this.health -= 5;
            this.happiness -= 10;
        }

        this.happiness = Math.max(0, Math.min(100, this.happiness));
        this.health = Math.max(0, Math.min(100, this.health));
    }
}

// ==========================================
// GAME STATE
// ==========================================

const Game = {
    canvas: null,
    ctx: null,
    world: null,
    player: null,
    animals: [],
    camera: { x: 0, y: 0 },
    keys: { up: false, down: false, left: false, right: false, interact: false },
    hoverTile: null, // {x, y} of tile mouse is hovering over
    money: 500,
    day: 1,
    season: 'Spring',
    year: 1,
    dayTimer: 0,
    DAY_LENGTH: 1800, // frames per day (30 seconds at 60fps)
    running: false,
    dialogOpen: false,
    lastInteract: false,

    // New systems
    energy: 100,
    maxEnergy: 100,
    selectedSlot: 0,
    inventory: [], // Array of {item, count}
    crops: [], // Array of {x, y, type, age, watered}
    npcs: [], // Array of NPC instances
    timeOfDay: 0, // 0-1 for day/night cycle

    // Tutorial system
    tutorial: {
        active: true,
        step: 0,
        completed: [],
        shown: false
    },

    // Weather system
    weather: {
        type: 'sunny', // sunny, cloudy, rainy, stormy
        particles: [],
        nextChange: 0
    },

    // Shipping bin & sprinklers
    shippingBin: [], // Items to sell at end of day
    sprinklers: [],  // {x, y} positions of placed sprinklers
    forageCooldowns: {}, // Track when forageables respawn
    clearedResources: [], // {x, y, type, respawnDay} for rocks/stumps to respawn

    // Achievements
    achievements: [],
    ACHIEVEMENT_DEFS: [
        { id: 'first_crop', name: 'Green Thumb', desc: 'Harvest your first crop', emoji: 'üå±' },
        { id: 'first_sale', name: 'Entrepreneur', desc: 'Make your first sale', emoji: 'üí∞' },
        { id: 'first_fish', name: 'Angler', desc: 'Catch your first fish', emoji: 'üé£' },
        { id: 'golden_catch', name: 'Lucky Catch', desc: 'Catch a Golden Fish', emoji: '‚ú®' },
        { id: 'first_animal', name: 'Animal Friend', desc: 'Buy your first animal', emoji: 'üê∑' },
        { id: 'full_farm', name: 'Farm Empire', desc: 'Have 10+ crops planted', emoji: 'üåæ' },
        { id: 'rich', name: 'Wealthy Farmer', desc: 'Have $1000 or more', emoji: 'üíé' },
        { id: 'very_rich', name: 'Millionaire', desc: 'Have $5000 or more', emoji: 'üëë' },
        { id: 'survivor', name: 'Survivor', desc: 'Survive 30 days', emoji: 'üìÖ' },
        { id: 'year_one', name: 'Veteran', desc: 'Complete Year 1', emoji: 'üèÜ' },
        { id: 'social', name: 'Social Butterfly', desc: 'Talk to all NPCs', emoji: 'üí¨' },
        { id: 'storm_survivor', name: 'Storm Chaser', desc: 'Experience a storm', emoji: '‚õàÔ∏è' },
        // Skill achievements
        { id: 'skilled', name: 'Getting Good', desc: 'Reach level 5 in any skill', emoji: '‚¨ÜÔ∏è' },
        { id: 'master', name: 'Master', desc: 'Reach level 10 in any skill', emoji: 'üéì' },
        // Tool achievements
        { id: 'first_upgrade', name: 'Upgraded!', desc: 'Upgrade any tool', emoji: 'üîß' },
        { id: 'gold_tool', name: 'Golden Touch', desc: 'Get a Gold tier tool', emoji: 'ü•á' },
        // Crafting achievements
        { id: 'first_craft', name: 'Craftsman', desc: 'Craft your first item', emoji: 'üî®' },
        { id: 'sprinkler_master', name: 'Irrigation Expert', desc: 'Place 5 sprinklers', emoji: 'üíß' },
        // Resource achievements
        { id: 'rock_collector', name: 'Rock Collector', desc: 'Gather 50 stone total', emoji: 'ü™®' },
        { id: 'lumberjack', name: 'Lumberjack', desc: 'Gather 50 wood total', emoji: 'ü™µ' },
        // Foraging
        { id: 'forager', name: 'Forager', desc: 'Forage 10 items', emoji: 'ü´ê' },
        // Animal achievements
        { id: 'full_menagerie', name: 'Full Menagerie', desc: 'Own all 4 animal types', emoji: 'üêæ' },
        { id: 'egg_collector', name: 'Egg Collector', desc: 'Collect 10 eggs', emoji: 'ü•ö' },
        { id: 'feather_collector', name: 'Feather Collector', desc: 'Collect 10 feathers', emoji: 'ü™∂' },
        { id: 'wool_collector', name: 'Wool Gatherer', desc: 'Collect 10 wool', emoji: 'üß∂' },
        { id: 'truffle_finder', name: 'Truffle Hunter', desc: 'Find a truffle', emoji: 'üçÑ' },
        { id: 'animal_rancher', name: 'Animal Rancher', desc: 'Own 10 animals', emoji: 'üè°' },
        { id: 'artisan', name: 'Artisan', desc: 'Craft an artisan good', emoji: 'üè∫' },
    ],
    // Lifetime stats for achievements
    lifetimeStats: {
        stoneGathered: 0,
        woodGathered: 0,
        itemsForaged: 0,
        eggsCollected: 0,
        feathersCollected: 0,
        woolCollected: 0,
        trufflesFound: 0
    },
    npcsTalkedTo: [],

    // Skills system
    skills: {
        farming: { level: 1, xp: 0 },
        fishing: { level: 1, xp: 0 },
        foraging: { level: 1, xp: 0 },
        mining: { level: 1, xp: 0 }
    },
    XP_PER_LEVEL: 100, // XP needed for each level up

    // Tool upgrades (tier 0-3: Basic, Copper, Iron, Gold)
    toolUpgrades: {
        hoe: 0,
        watering_can: 0,
        pickaxe: 0,
        axe: 0,
        fishing_rod: 0
    },

    // Tutorial steps
    TUTORIAL_STEPS: [
        {
            id: 'welcome',
            title: 'Welcome to Texas Farms!',
            text: 'This tutorial will teach you the basics of farming. You can skip it anytime by pressing ESC.',
            trigger: 'auto',
            arrow: null
        },
        {
            id: 'movement',
            title: 'Movement',
            text: 'Use WASD or Arrow keys to walk around. Try walking to the farm plot on the left!',
            trigger: 'auto',
            check: (game) => Math.abs(game.player.x - 5*48) < 100 && Math.abs(game.player.y - 9*48) < 100
        },
        {
            id: 'inventory',
            title: 'Inventory',
            text: 'Press 1-8 to select items in your toolbar at the bottom. Try pressing 1 to select your Hoe!',
            trigger: 'auto',
            check: (game) => game.selectedSlot === 0
        },
        {
            id: 'till',
            title: 'Tilling Soil',
            text: 'With the Hoe selected, face a grass tile and press E to till it into farmland. Try it now!',
            trigger: 'auto',
            check: (game) => game.tutorial.completed.includes('tilled')
        },
        {
            id: 'seeds',
            title: 'Planting Seeds',
            text: 'Press 6 to select Turnip Seeds. Then face tilled soil and press E to plant!',
            trigger: 'auto',
            check: (game) => game.crops.length > 0
        },
        {
            id: 'water',
            title: 'Watering Crops',
            text: 'Press 2 to select Watering Can. Water your planted crop by pressing E. Crops only grow when watered!',
            trigger: 'auto',
            check: (game) => game.crops.some(c => c.watered)
        },
        {
            id: 'energy',
            title: 'Energy System',
            text: 'Actions use energy (green bar, top-right). Sleep at your farmhouse (door on the white building) to restore it!',
            trigger: 'auto',
            check: (game) => game.tutorial.completed.includes('slept')
        },
        {
            id: 'fishing',
            title: 'Fishing',
            text: 'Press 5 to select your Fishing Rod. Face the pond water and press E to fish! Press E again when you see "!"',
            trigger: 'auto',
            check: (game) => game.tutorial.completed.includes('caught_fish')
        },
        {
            id: 'npcs',
            title: 'Meeting NPCs',
            text: 'Walk up to villagers and press E to talk. Sally at the Market sells seeds. The Mayor is near your house.',
            trigger: 'auto',
            check: (game) => game.tutorial.completed.includes('talked_npc')
        },
        {
            id: 'market',
            title: 'The Market',
            text: 'Go to the Market Stall (store icon, bottom center) and press E. You can buy seeds, animals, and sell crops!',
            trigger: 'auto',
            check: (game) => game.tutorial.completed.includes('visited_market')
        },
        {
            id: 'complete',
            title: 'Tutorial Complete!',
            text: 'You learned the basics! Plant crops, raise animals, fish, and make friends. Day changes every 30 seconds. Good luck!',
            trigger: 'auto',
            check: () => true
        }
    ],

    init() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());

        // Keyboard input
        window.addEventListener('keydown', (e) => this.handleKeyDown(e));
        window.addEventListener('keyup', (e) => this.handleKeyUp(e));

        // Touch controls for mobile
        this.setupTouchControls();

        // Mouse click for interaction
        this.canvas.addEventListener('click', (e) => this.handleClick(e));

        // Mouse move for hover indicator
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseleave', () => this.hoverTile = null);

        // Show continue button if save exists
        if (this.hasSaveGame()) {
            document.getElementById('continue-btn').style.display = 'inline-block';
        }
    },

    handleClick(e) {
        if (!this.running || this.dialogOpen) return;

        // Convert click position to world coordinates
        const rect = this.canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left + this.camera.x;
        const clickY = e.clientY - rect.top + this.camera.y;

        // Convert to tile coordinates
        const tileX = Math.floor(clickX / TILE_SIZE);
        const tileY = Math.floor(clickY / TILE_SIZE);

        // Check if click is within interaction range of player (2 tiles)
        const playerTileX = Math.floor(this.player.x / TILE_SIZE);
        const playerTileY = Math.floor(this.player.y / TILE_SIZE);
        const dist = Math.abs(tileX - playerTileX) + Math.abs(tileY - playerTileY);

        if (dist <= 2 && dist > 0) {
            // Face the clicked tile
            if (tileX > playerTileX) this.player.direction = 'right';
            else if (tileX < playerTileX) this.player.direction = 'left';
            else if (tileY > playerTileY) this.player.direction = 'down';
            else if (tileY < playerTileY) this.player.direction = 'up';

            // Perform interaction at clicked tile
            this.tryInteractAt(tileX, tileY);
        }
    },

    handleMouseMove(e) {
        if (!this.running) return;

        const rect = this.canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left + this.camera.x;
        const clickY = e.clientY - rect.top + this.camera.y;

        const tileX = Math.floor(clickX / TILE_SIZE);
        const tileY = Math.floor(clickY / TILE_SIZE);

        const playerTileX = Math.floor(this.player.x / TILE_SIZE);
        const playerTileY = Math.floor(this.player.y / TILE_SIZE);
        const dist = Math.abs(tileX - playerTileX) + Math.abs(tileY - playerTileY);

        if (dist <= 2 && dist > 0) {
            this.hoverTile = { x: tileX, y: tileY };
        } else {
            this.hoverTile = null;
        }
    },

    tryInteractAt(tileX, tileY) {
        // Check for NPCs at clicked tile
        const nearbyNPC = this.npcs.find(npc => {
            const nx = Math.floor(npc.x / TILE_SIZE);
            const ny = Math.floor(npc.y / TILE_SIZE);
            return nx === tileX && ny === tileY;
        });

        if (nearbyNPC) {
            this.showNPCDialog(nearbyNPC);
            return;
        }

        // Check for animals at clicked tile
        const nearbyAnimal = this.animals.find(a => {
            const ax = Math.floor(a.x / TILE_SIZE);
            const ay = Math.floor(a.y / TILE_SIZE);
            return ax === tileX && ay === tileY;
        });

        if (nearbyAnimal) {
            this.showAnimalDialog(nearbyAnimal);
            return;
        }

        // Check tiles
        if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
            const tile = this.world[tileY][tileX];

            // Check for building interactions
            if (tile === TILES.MARKET_STALL) {
                this.showMarketDialog();
                return;
            } else if (tile === TILES.TROUGH) {
                this.feedAnimals();
                return;
            } else if (tile === TILES.DOOR && tileX >= 20) {
                this.showBarnDialog();
                return;
            } else if (tile === TILES.DOOR && tileX < 15) {
                this.showHouseDialog();
                return;
            } else if (tile === TILES.SHIPPING_BIN) {
                this.showShippingBinDialog();
                return;
            } else if (tile === TILES.BERRY_BUSH) {
                this.forageBerryBush(tileX, tileY);
                return;
            }

            // Check for crop harvest
            const crop = this.crops.find(c => c.x === tileX && c.y === tileY);
            if (crop) {
                const seedItem = Object.values(ITEMS).find(i => i.crop === crop.type);
                if (crop.age >= seedItem.growDays) {
                    this.harvestCrop(crop);
                    return;
                }
            }

            // Use currently selected tool/item
            const selectedItem = this.inventory[this.selectedSlot];
            if (selectedItem) {
                this.useItem(selectedItem.item, tileX, tileY, tile, crop);
            }
        }
    },

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    },

    handleKeyDown(e) {
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') this.keys.up = true;
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') this.keys.down = true;
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') this.keys.left = true;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') this.keys.right = true;
        if (e.key === 'e' || e.key === 'E' || e.key === ' ') {
            e.preventDefault();
            this.keys.interact = true;
        }
        if (e.key === 'Escape') this.closeDialog();

        // Number keys 1-8 for inventory slots
        const num = parseInt(e.key);
        if (num >= 1 && num <= 8) {
            this.selectSlot(num - 1);
        }

        // Q to drop/use item info
        if (e.key === 'q' || e.key === 'Q') {
            this.showItemInfo();
        }

        // H for help
        if (e.key === 'h' || e.key === 'H') {
            this.showHelpDialog();
        }

        // Tab for achievements
        if (e.key === 'Tab') {
            e.preventDefault();
            this.showAchievementsDialog();
        }

        // C for crafting
        if (e.key === 'c' || e.key === 'C') {
            this.showCraftingDialog();
        }

        // K for skills
        if (e.key === 'k' || e.key === 'K') {
            this.showSkillsDialog();
        }

        // M for music toggle
        if (e.key === 'm' || e.key === 'M') {
            this.toggleMusic();
        }

        // U for tool upgrades
        if (e.key === 'u' || e.key === 'U') {
            this.showToolUpgradeDialog();
        }
    },

    handleKeyUp(e) {
        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') this.keys.up = false;
        if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') this.keys.down = false;
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') this.keys.left = false;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') this.keys.right = false;
        if (e.key === 'e' || e.key === 'E' || e.key === ' ') this.keys.interact = false;
    },

    setupTouchControls() {
        let touchStart = null;

        this.canvas.addEventListener('touchstart', (e) => {
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });

        this.canvas.addEventListener('touchmove', (e) => {
            if (!touchStart) return;
            const dx = e.touches[0].clientX - touchStart.x;
            const dy = e.touches[0].clientY - touchStart.y;

            this.keys.left = dx < -20;
            this.keys.right = dx > 20;
            this.keys.up = dy < -20;
            this.keys.down = dy > 20;
        });

        this.canvas.addEventListener('touchend', () => {
            touchStart = null;
            this.keys = { up: false, down: false, left: false, right: false, interact: false };
        });

        // Double tap to interact
        let lastTap = 0;
        this.canvas.addEventListener('touchstart', (e) => {
            const now = Date.now();
            if (now - lastTap < 300) {
                this.keys.interact = true;
                setTimeout(() => this.keys.interact = false, 100);
            }
            lastTap = now;
        });
    },

    start() {
        document.getElementById('title-screen').style.display = 'none';

        // Generate world
        this.world = generateWorld();

        // Create player
        this.player = new Player(10 * TILE_SIZE, 10 * TILE_SIZE);

        // Initialize inventory with starter tools
        this.inventory = [
            { item: ITEMS.HOE, count: 1 },
            { item: ITEMS.WATERING_CAN, count: 1 },
            { item: ITEMS.PICKAXE, count: 1 },
            { item: ITEMS.AXE, count: 1 },
            { item: ITEMS.FISHING_ROD, count: 1 },
            { item: ITEMS.TURNIP_SEEDS, count: 10 },
            null, null
        ];

        // Fishing state
        this.fishing = {
            active: false,
            phase: 'idle', // 'idle', 'casting', 'waiting', 'bite', 'reeling'
            timer: 0,
            biteWindow: 0,
            targetFish: null
        };

        // Reset game state
        this.animals = [];
        this.crops = [];
        this.energy = 100;
        this.money = 500;
        this.day = 1;
        this.season = 'Spring';
        this.year = 1;
        this.timeOfDay = 0.25; // Start at morning

        // Create NPCs
        this.npcs = [
            new NPC(11 * TILE_SIZE, 16 * TILE_SIZE, 'shopkeeper'), // At market stall
            new NPC(9 * TILE_SIZE, 8 * TILE_SIZE, 'mayor'),        // Near house
            new NPC(14 * TILE_SIZE, 12 * TILE_SIZE, 'wanderer'),   // Wandering
        ];

        this.updateInventoryUI();
        this.running = true;
        this.gameLoop();

        // Show first tutorial step after a brief delay
        setTimeout(() => this.showTutorialStep(), 500);
    },

    showTutorialStep() {
        if (!this.tutorial.active) return;

        const step = this.TUTORIAL_STEPS[this.tutorial.step];
        if (!step) {
            this.tutorial.active = false;
            return;
        }

        let html = `<strong>Tutorial: ${step.title}</strong><br><br>`;
        html += step.text;

        let options = '';
        if (step.id === 'complete') {
            options = `<button onclick="Game.finishTutorial()">Start Farming!</button>`;
        } else {
            options = `<button onclick="Game.closeTutorialStep()">Got it!</button>`;
            options += `<button onclick="Game.skipTutorial()">Skip Tutorial</button>`;
        }

        this.showDialog(html, options);
    },

    closeTutorialStep() {
        this.closeDialog();
        this.tutorial.shown = true;
    },

    skipTutorial() {
        this.tutorial.active = false;
        this.closeDialog();
        this.showToast('Tutorial skipped. Press H anytime for help!');
    },

    finishTutorial() {
        this.tutorial.active = false;
        this.closeDialog();
        this.showToast('Tutorial complete! Enjoy your farm!');
    },

    updateTutorial() {
        if (!this.tutorial.active || !this.tutorial.shown) return;

        const step = this.TUTORIAL_STEPS[this.tutorial.step];
        if (!step || !step.check) return;

        if (step.check(this)) {
            this.tutorial.step++;
            this.tutorial.shown = false;
            // Small delay before showing next step
            setTimeout(() => this.showTutorialStep(), 300);
        }
    },

    completeTutorialAction(action) {
        if (!this.tutorial.completed.includes(action)) {
            this.tutorial.completed.push(action);
        }
    },

    showHelpDialog() {
        let html = '<strong>Game Controls</strong><br><br>';
        html += '<b>Movement:</b> WASD or Arrow Keys<br>';
        html += '<b>Interact:</b> Click nearby tiles or press E<br>';
        html += '<b>Select Item:</b> 1-8 keys<br>';
        html += '<b>Item Info:</b> Q key<br>';
        html += '<b>Skills:</b> K key<br>';
        html += '<b>Crafting:</b> C key<br>';
        html += '<b>Tool Upgrades:</b> U key<br>';
        html += '<b>Achievements:</b> Tab key<br>';
        html += '<b>Music:</b> M key<br>';
        html += '<b>Help:</b> H key<br><br>';

        html += '<b>Tools:</b><br>';
        html += '- Hoe: Till grass into farmland<br>';
        html += '- Watering Can: Water crops<br>';
        html += '- Pickaxe: Break rocks for stone<br>';
        html += '- Axe: Chop stumps for wood<br>';
        html += '- Fishing Rod: Fish in the pond<br><br>';

        html += '<b>Skills (K key):</b><br>';
        html += '- Farming: +5% crop yield per level<br>';
        html += '- Fishing: +5% rare fish chance per level<br>';
        html += '- Foraging: +5% forage quantity per level<br>';
        html += '- Mining: +5% resource yield per level<br><br>';

        html += '<b>Tips:</b><br>';
        html += '- Click tiles within 2 tiles to interact!<br>';
        html += '- Yellow outline shows clickable tiles<br>';
        html += '- Game auto-saves at the end of each day<br>';

        this.showDialog(html, `<button onclick="Game.closeDialog()">Got it!</button>`);
    },

    showAchievementsDialog() {
        const unlocked = this.achievements.length;
        const total = this.ACHIEVEMENT_DEFS.length;

        let html = `<strong>Achievements (${unlocked}/${total})</strong><br><br>`;

        this.ACHIEVEMENT_DEFS.forEach(ach => {
            const isUnlocked = this.achievements.includes(ach.id);
            if (isUnlocked) {
                html += `<span style="color:#4ade80">${ach.emoji} <b>${ach.name}</b> - ${ach.desc}</span><br>`;
            } else {
                html += `<span style="color:#666">üîí <b>???</b> - ${ach.desc}</span><br>`;
            }
        });

        this.showDialog(html, `<button onclick="Game.closeDialog()">Close</button>`);
    },

    showCraftingDialog() {
        let html = '<strong>üî® Crafting</strong><br><br>';

        // Count resources and products in inventory
        const resources = {};
        this.inventory.forEach(slot => {
            if (slot && (slot.item.type === 'resource' || slot.item.type === 'product')) {
                resources[slot.item.id] = (resources[slot.item.id] || 0) + slot.count;
            }
        });

        html += `<b>Materials:</b> `;
        html += `ü™®${resources.stone || 0} ü™µ${resources.wood || 0}`;
        if (resources.egg) html += ` ü•ö${resources.egg}`;
        if (resources.feather) html += ` ü™∂${resources.feather}`;
        if (resources.wool) html += ` üß∂${resources.wool}`;
        if (resources.truffle) html += ` üçÑ${resources.truffle}`;
        html += `<br><br>`;
        html += `<b>Recipes:</b><br>`;

        let options = '';
        Object.entries(RECIPES).forEach(([key, recipe]) => {
            const canCraft = Object.entries(recipe.ingredients).every(([item, needed]) => {
                return (resources[item] || 0) >= needed;
            });

            const ingredientStr = Object.entries(recipe.ingredients)
                .map(([item, needed]) => `${needed} ${item}`)
                .join(', ');

            if (canCraft) {
                html += `<span style="color:#4ade80">${recipe.result.emoji} ${recipe.result.name}: ${ingredientStr}</span><br>`;
                options += `<button onclick="Game.craft('${key}')">${recipe.result.emoji} Craft ${recipe.result.name}</button>`;
            } else {
                html += `<span style="color:#666">${recipe.result.emoji} ${recipe.result.name}: ${ingredientStr}</span><br>`;
            }
        });

        options += `<button onclick="Game.closeDialog()">Close</button>`;
        this.showDialog(html, options);
    },

    craft(recipeKey) {
        const recipe = RECIPES[recipeKey];
        if (!recipe) return;

        // Check if we have ingredients (resources + products)
        const resources = {};
        this.inventory.forEach(slot => {
            if (slot && (slot.item.type === 'resource' || slot.item.type === 'product')) {
                resources[slot.item.id] = (resources[slot.item.id] || 0) + slot.count;
            }
        });

        const canCraft = Object.entries(recipe.ingredients).every(([item, needed]) => {
            return (resources[item] || 0) >= needed;
        });

        if (!canCraft) {
            this.showToast('Not enough materials!');
            Audio.play('error');
            return;
        }

        // Remove ingredients
        Object.entries(recipe.ingredients).forEach(([itemId, needed]) => {
            let remaining = needed;
            for (let i = 0; i < this.inventory.length && remaining > 0; i++) {
                const slot = this.inventory[i];
                if (slot && slot.item.id === itemId) {
                    const take = Math.min(slot.count, remaining);
                    slot.count -= take;
                    remaining -= take;
                    if (slot.count <= 0) {
                        this.inventory[i] = null;
                    }
                }
            }
        });

        // Add result
        this.addToInventory(recipe.result, 1);
        this.updateInventoryUI();
        Audio.play('harvest');
        this.showToast(`Crafted ${recipe.result.emoji} ${recipe.result.name}!`);

        // Crafting achievements
        this.unlockAchievement('first_craft');
        if (recipe.result.type === 'artisan') {
            this.unlockAchievement('artisan');
        }

        this.showCraftingDialog(); // Refresh
    },

    showSkillsDialog() {
        let html = '<strong>üìä Skills</strong><br><br>';

        const skillInfo = {
            farming: { emoji: 'üåæ', name: 'Farming', bonus: 'Crop sell price' },
            fishing: { emoji: 'üé£', name: 'Fishing', bonus: 'Rare fish chance' },
            foraging: { emoji: 'üçÑ', name: 'Foraging', bonus: 'Forage quantity' },
            mining: { emoji: '‚õèÔ∏è', name: 'Mining', bonus: 'Resource yield' }
        };

        Object.entries(this.skills).forEach(([key, skill]) => {
            const info = skillInfo[key];
            const xpToNext = this.XP_PER_LEVEL - (skill.xp % this.XP_PER_LEVEL);
            const progress = Math.floor((skill.xp % this.XP_PER_LEVEL) / this.XP_PER_LEVEL * 100);
            const bonusPercent = (skill.level - 1) * 5;

            html += `<div style="margin-bottom:10px">`;
            html += `${info.emoji} <b>${info.name}</b> - Level ${skill.level}<br>`;
            html += `<span style="color:#888">+${bonusPercent}% ${info.bonus}</span><br>`;
            html += `<div style="background:#333;height:8px;border-radius:4px;width:150px;display:inline-block">`;
            html += `<div style="background:#4ade80;height:100%;width:${progress}%;border-radius:4px"></div>`;
            html += `</div> <span style="color:#666;font-size:12px">${xpToNext} XP to next</span>`;
            html += `</div>`;
        });

        html += `<br><em style="color:#888">Gain XP by doing activities!</em>`;

        this.showDialog(html, `<button onclick="Game.closeDialog()">Close</button>`);
    },

    addSkillXP(skillName, amount) {
        const skill = this.skills[skillName];
        if (!skill) return;

        const oldLevel = skill.level;
        skill.xp += amount;
        skill.level = 1 + Math.floor(skill.xp / this.XP_PER_LEVEL);

        if (skill.level > oldLevel) {
            const skillNames = {
                farming: 'Farming',
                fishing: 'Fishing',
                foraging: 'Foraging',
                mining: 'Mining'
            };
            this.showToast(`‚¨ÜÔ∏è ${skillNames[skillName]} leveled up to ${skill.level}!`);
            Audio.play('catch');

            // Check skill achievements
            if (skill.level >= 5) this.unlockAchievement('skilled');
            if (skill.level >= 10) this.unlockAchievement('master');
        }
    },

    getSkillBonus(skillName) {
        const skill = this.skills[skillName];
        if (!skill) return 1;
        // 5% bonus per level above 1
        return 1 + (skill.level - 1) * 0.05;
    },

    // Tool upgrade methods
    getToolTier(toolId) {
        return this.toolUpgrades[toolId] || 0;
    },

    getToolTierInfo(toolId) {
        const tier = this.getToolTier(toolId);
        return TOOL_TIERS[tier];
    },

    getToolEnergyMultiplier(toolId) {
        const tierInfo = this.getToolTierInfo(toolId);
        return tierInfo ? tierInfo.energyMult : 1;
    },

    getToolYieldMultiplier(toolId) {
        const tierInfo = this.getToolTierInfo(toolId);
        return tierInfo ? tierInfo.yieldMult : 1;
    },

    canUpgradeTool(toolId) {
        const currentTier = this.getToolTier(toolId);
        if (currentTier >= 3) return false; // Max tier

        const nextTier = currentTier + 1;
        const cost = TOOL_UPGRADE_COSTS[nextTier];

        // Count resources
        const resources = {};
        this.inventory.forEach(slot => {
            if (slot && slot.item.type === 'resource') {
                resources[slot.item.id] = (resources[slot.item.id] || 0) + slot.count;
            }
        });

        return this.money >= cost.money &&
               (resources.stone || 0) >= cost.stone &&
               (resources.wood || 0) >= cost.wood;
    },

    upgradeTool(toolId) {
        if (!this.canUpgradeTool(toolId)) {
            Audio.play('error');
            return false;
        }

        const currentTier = this.getToolTier(toolId);
        const nextTier = currentTier + 1;
        const cost = TOOL_UPGRADE_COSTS[nextTier];

        // Deduct money
        this.money -= cost.money;

        // Remove resources from inventory
        let stoneNeeded = cost.stone;
        let woodNeeded = cost.wood;

        for (let i = 0; i < this.inventory.length; i++) {
            const slot = this.inventory[i];
            if (!slot) continue;

            if (slot.item.id === 'stone' && stoneNeeded > 0) {
                const take = Math.min(slot.count, stoneNeeded);
                slot.count -= take;
                stoneNeeded -= take;
                if (slot.count <= 0) this.inventory[i] = null;
            }
            if (slot.item.id === 'wood' && woodNeeded > 0) {
                const take = Math.min(slot.count, woodNeeded);
                slot.count -= take;
                woodNeeded -= take;
                if (slot.count <= 0) this.inventory[i] = null;
            }
        }

        // Upgrade the tool
        this.toolUpgrades[toolId] = nextTier;

        const tierInfo = TOOL_TIERS[nextTier];
        const toolName = this.getToolDisplayName(toolId);

        Audio.play('achievement');
        this.showToast(`üîß ${toolName} upgraded to ${tierInfo.name}!`);
        this.updateInventoryUI();

        // Tool upgrade achievements
        this.unlockAchievement('first_upgrade');
        if (nextTier === 3) this.unlockAchievement('gold_tool');

        return true;
    },

    getToolDisplayName(toolId) {
        const tier = this.getToolTier(toolId);
        const tierInfo = TOOL_TIERS[tier];
        const toolNames = {
            hoe: 'Hoe',
            watering_can: 'Watering Can',
            pickaxe: 'Pickaxe',
            axe: 'Axe',
            fishing_rod: 'Fishing Rod'
        };
        const baseName = toolNames[toolId] || toolId;
        return tier > 0 ? `${tierInfo.name} ${baseName}` : baseName;
    },

    showToolUpgradeDialog() {
        let html = '<strong>üîß Tool Upgrades</strong><br><br>';

        // Count resources
        const resources = {};
        this.inventory.forEach(slot => {
            if (slot && slot.item.type === 'resource') {
                resources[slot.item.id] = (resources[slot.item.id] || 0) + slot.count;
            }
        });

        const stoneHave = resources.stone || 0;
        const woodHave = resources.wood || 0;

        html += `<span style="color:#888">Your resources: ü™® ${stoneHave} Stone | ü™µ ${woodHave} Wood | üí∞ $${this.money}</span><br><br>`;

        const tools = [
            { id: 'hoe', emoji: 'üî®' },
            { id: 'watering_can', emoji: 'ü™£' },
            { id: 'pickaxe', emoji: '‚õèÔ∏è' },
            { id: 'axe', emoji: 'ü™ì' },
            { id: 'fishing_rod', emoji: 'üé£' }
        ];

        tools.forEach(tool => {
            const tier = this.getToolTier(tool.id);
            const tierInfo = TOOL_TIERS[tier];
            const displayName = this.getToolDisplayName(tool.id);

            html += `<div style="margin-bottom:8px;">`;
            html += `<span style="color:${tierInfo.color}">${tool.emoji} <b>${displayName}</b></span>`;
            html += ` <span style="color:#666">(Energy: ${Math.round((1-tierInfo.energyMult)*100)}% less, Yield: +${Math.round((tierInfo.yieldMult-1)*100)}%)</span>`;

            if (tier < 3) {
                const nextTier = tier + 1;
                const cost = TOOL_UPGRADE_COSTS[nextTier];
                const nextTierInfo = TOOL_TIERS[nextTier];
                const canUpgrade = this.canUpgradeTool(tool.id);

                html += `<br><span style="font-size:11px;color:#888">`;
                html += `‚ûú ${nextTierInfo.name}: $${cost.money} + ü™®${cost.stone} + ü™µ${cost.wood}`;
                html += `</span>`;

                if (canUpgrade) {
                    html += ` <button onclick="Game.upgradeTool('${tool.id}'); Game.showToolUpgradeDialog();" style="font-size:11px;padding:2px 6px;">Upgrade</button>`;
                }
            } else {
                html += ` <span style="color:#ffd700">‚òÖ MAX</span>`;
            }
            html += `</div>`;
        });

        html += '<br><span style="color:#888;font-size:11px">Better tools use less energy and gather more resources!</span>';

        this.showDialog(html, `<button onclick="Game.closeDialog()">Close</button>`);
    },

    gameLoop() {
        if (!this.running) return;

        this.update();
        this.render();

        requestAnimationFrame(() => this.gameLoop());
    },

    update() {
        if (this.dialogOpen) return;

        // Update player
        this.player.update(this.keys, this.world, this.animals);

        // Update camera to follow player
        this.camera.x = this.player.x - this.canvas.width / 2 + TILE_SIZE / 2;
        this.camera.y = this.player.y - this.canvas.height / 2 + TILE_SIZE / 2;

        // Keep camera in bounds
        this.camera.x = Math.max(0, Math.min(this.camera.x, WORLD_WIDTH * TILE_SIZE - this.canvas.width));
        this.camera.y = Math.max(0, Math.min(this.camera.y, WORLD_HEIGHT * TILE_SIZE - this.canvas.height));

        // Update animals
        this.animals.forEach(a => a.update(this.world));

        // Update NPCs
        this.npcs.forEach(npc => npc.update(this.world, this.day));

        // Update fishing
        this.updateFishing();

        // Day/night cycle and time of day
        this.dayTimer++;
        this.timeOfDay = this.dayTimer / this.DAY_LENGTH;
        if (this.dayTimer >= this.DAY_LENGTH) {
            this.advanceDay();
        }

        // Handle interactions
        if (this.keys.interact && !this.lastInteract) {
            this.tryInteract();
        }
        this.lastInteract = this.keys.interact;

        // Update HUD and energy bar
        this.updateHUD();
        document.getElementById('energy-fill-inner').style.width = `${this.energy}%`;

        // Update tutorial
        this.updateTutorial();

        // Update weather
        this.updateWeather();

        // Check achievements
        this.checkAchievements();
    },

    checkAchievements() {
        // Rich achievements
        if (this.money >= 1000) this.unlockAchievement('rich');
        if (this.money >= 5000) this.unlockAchievement('very_rich');

        // Farm size
        if (this.crops.length >= 10) this.unlockAchievement('full_farm');

        // Days survived
        const totalDays = (this.year - 1) * 120 + (this.getSeasonIndex() * 30) + this.day;
        if (totalDays >= 30) this.unlockAchievement('survivor');
        if (this.year >= 2) this.unlockAchievement('year_one');

        // Social
        if (this.npcsTalkedTo.length >= 3) this.unlockAchievement('social');

        // Storm
        if (this.weather.type === 'stormy') this.unlockAchievement('storm_survivor');
    },

    getSeasonIndex() {
        return ['Spring', 'Summer', 'Fall', 'Winter'].indexOf(this.season);
    },

    unlockAchievement(id) {
        if (this.achievements.includes(id)) return;

        const achievement = this.ACHIEVEMENT_DEFS.find(a => a.id === id);
        if (!achievement) return;

        this.achievements.push(id);
        Audio.play('catch'); // Achievement sound

        // Show achievement popup
        this.showToast(`Achievement Unlocked: ${achievement.emoji} ${achievement.name}`);

        // Save achievements
        localStorage.setItem('texasfarms_achievements', JSON.stringify(this.achievements));
    },

    updateWeather() {
        // Random weather changes
        this.weather.nextChange--;
        if (this.weather.nextChange <= 0) {
            const roll = Math.random();
            const seasonMod = this.season === 'Spring' ? 0.1 : this.season === 'Summer' ? -0.1 : this.season === 'Fall' ? 0.05 : 0.15;

            if (roll < 0.5 + seasonMod) {
                this.weather.type = 'sunny';
            } else if (roll < 0.7 + seasonMod) {
                this.weather.type = 'cloudy';
            } else if (roll < 0.9 + seasonMod) {
                this.weather.type = 'rainy';
            } else {
                this.weather.type = 'stormy';
            }

            // Weather lasts 3-10 minutes of real time
            this.weather.nextChange = 180 * 60 + Math.random() * 420 * 60;

            // Announce weather changes
            if (this.weather.type === 'rainy') {
                this.showToast('Rain is starting to fall...');
            } else if (this.weather.type === 'stormy') {
                this.showToast('A storm is rolling in!');
            }
        }

        // Update rain particles
        if (this.weather.type === 'rainy' || this.weather.type === 'stormy') {
            // Add new particles
            const intensity = this.weather.type === 'stormy' ? 8 : 4;
            for (let i = 0; i < intensity; i++) {
                this.weather.particles.push({
                    x: Math.random() * this.canvas.width,
                    y: -10,
                    speed: 8 + Math.random() * 4,
                    length: this.weather.type === 'stormy' ? 20 : 12
                });
            }

            // Update existing particles
            this.weather.particles = this.weather.particles.filter(p => {
                p.y += p.speed;
                p.x -= p.speed * 0.3; // Wind effect
                return p.y < this.canvas.height + 20;
            });

            // Limit particle count
            if (this.weather.particles.length > 500) {
                this.weather.particles = this.weather.particles.slice(-500);
            }
        } else {
            this.weather.particles = [];
        }
    },

    advanceDay() {
        this.dayTimer = 0;
        this.day++;
        this.timeOfDay = 0.25; // Reset to morning

        // Restore energy when new day starts
        this.energy = this.maxEnergy;

        // Season change every 30 days
        if (this.day > 30) {
            this.day = 1;
            const seasons = ['Spring', 'Summer', 'Fall', 'Winter'];
            const idx = seasons.indexOf(this.season);
            const oldSeason = this.season;
            this.season = seasons[(idx + 1) % 4];
            if (this.season === 'Spring') this.year++;
            this.showToast(`${this.season} has arrived!`);

            // Wither crops that can't survive in the new season
            const witheredCrops = this.crops.filter(crop => {
                const seedItem = Object.values(ITEMS).find(i => i.crop === crop.type);
                return seedItem && seedItem.seasons && !seedItem.seasons.includes(this.season);
            });

            if (witheredCrops.length > 0) {
                witheredCrops.forEach(crop => {
                    this.world[crop.y][crop.x] = TILES.TILLED;
                });
                this.crops = this.crops.filter(crop => {
                    const seedItem = Object.values(ITEMS).find(i => i.crop === crop.type);
                    return !seedItem || !seedItem.seasons || seedItem.seasons.includes(this.season);
                });
                this.showToast(`${witheredCrops.length} crops withered in the new season!`);
            }
        }

        // Age animals
        this.animals.forEach(a => a.advanceDay());

        // Check for animal products
        let productsReady = 0;
        this.animals.forEach(a => {
            const product = a.checkProduct();
            if (product) productsReady++;
        });
        if (productsReady > 0) {
            this.showToast(`ü•ö ${productsReady} animals have products ready to collect!`);
        }

        // Remove dead animals
        const dead = this.animals.filter(a => a.health <= 0);
        if (dead.length > 0) {
            this.showToast(`${dead.map(a => a.name).join(', ')} died from neglect!`);
        }
        this.animals = this.animals.filter(a => a.health > 0);

        // Auto-water crops if it rained
        const wasRainy = this.weather.type === 'rainy' || this.weather.type === 'stormy';
        if (wasRainy) {
            this.crops.forEach(crop => {
                crop.watered = true;
                this.world[crop.y][crop.x] = TILES.WATERED;
            });
            this.showToast('The rain watered all your crops!');
        }

        // Sprinkler auto-watering
        this.sprinklers.forEach(sprinkler => {
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const crop = this.crops.find(c => c.x === sprinkler.x + dx && c.y === sprinkler.y + dy);
                    if (crop) {
                        crop.watered = true;
                        this.world[crop.y][crop.x] = TILES.WATERED;
                    }
                }
            }
        });

        // Grow crops
        this.crops.forEach(crop => {
            if (crop.watered) {
                crop.age++;
                crop.watered = false; // Reset watered status each day
                // Reset tile to tilled (from watered)
                this.world[crop.y][crop.x] = TILES.TILLED;
            }
        });

        // Process shipping bin - sell items overnight
        if (this.shippingBin.length > 0) {
            const total = this.shippingBin.reduce((sum, item) => sum + (item.item.sellPrice || 0) * item.count, 0);
            this.money += total;
            const itemCount = this.shippingBin.reduce((sum, item) => sum + item.count, 0);
            this.showToast(`üì¶ Shipping: +$${total} for ${itemCount} items!`);
            Audio.play('sell');
            this.shippingBin = [];
            this.unlockAchievement('first_sale');
        }

        // Respawn cleared resources
        const toRespawn = this.clearedResources.filter(r => r.respawnDay <= this.day);
        toRespawn.forEach(r => {
            // Only respawn if tile is still grass
            if (this.world[r.y][r.x] === TILES.GRASS) {
                this.world[r.y][r.x] = r.type;
            }
        });
        this.clearedResources = this.clearedResources.filter(r => r.respawnDay > this.day);

        // Auto-save at end of each day
        this.saveGame();
    },

    tryInteract() {
        const point = this.player.getInteractionPoint();
        const tileX = Math.floor(point.x / TILE_SIZE);
        const tileY = Math.floor(point.y / TILE_SIZE);

        // Check for NPCs nearby
        const nearbyNPC = this.npcs.find(npc => {
            const nx = Math.floor(npc.x / TILE_SIZE);
            const ny = Math.floor(npc.y / TILE_SIZE);
            return Math.abs(nx - tileX) <= 1 && Math.abs(ny - tileY) <= 1;
        });

        if (nearbyNPC) {
            this.showNPCDialog(nearbyNPC);
            return;
        }

        // Check for animals nearby
        const nearbyAnimal = this.animals.find(a => {
            const ax = Math.floor(a.x / TILE_SIZE);
            const ay = Math.floor(a.y / TILE_SIZE);
            return Math.abs(ax - tileX) <= 1 && Math.abs(ay - tileY) <= 1;
        });

        if (nearbyAnimal) {
            this.showAnimalDialog(nearbyAnimal);
            return;
        }

        // Check tiles
        if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
            const tile = this.world[tileY][tileX];

            // Check for interactions with buildings first
            if (tile === TILES.MARKET_STALL) {
                this.showMarketDialog();
                return;
            } else if (tile === TILES.TROUGH) {
                this.feedAnimals();
                return;
            } else if (tile === TILES.DOOR && tileX >= 20) {
                this.showBarnDialog();
                return;
            } else if (tile === TILES.DOOR && tileX < 15) {
                this.showHouseDialog();
                return;
            } else if (tile === TILES.SHIPPING_BIN) {
                this.showShippingBinDialog();
                return;
            } else if (tile === TILES.BERRY_BUSH) {
                this.forageBerryBush(tileX, tileY);
                return;
            }

            // Check for crop harvest
            const crop = this.crops.find(c => c.x === tileX && c.y === tileY);
            if (crop) {
                const seedItem = Object.values(ITEMS).find(i => i.crop === crop.type);
                if (crop.age >= seedItem.growDays) {
                    this.harvestCrop(crop);
                    return;
                }
            }

            // Use currently selected tool/item
            const selectedItem = this.inventory[this.selectedSlot];
            if (!selectedItem) {
                // No item selected - just show what's there
                if (crop) {
                    const seedItem = Object.values(ITEMS).find(i => i.crop === crop.type);
                    const daysLeft = seedItem.growDays - crop.age;
                    this.showToast(`${crop.type}: ${daysLeft > 0 ? daysLeft + ' days until harvest' : 'Ready!'}`);
                }
                return;
            }

            // Use the selected item/tool
            this.useItem(selectedItem.item, tileX, tileY, tile, crop);
        }
    },

    useItem(item, tileX, tileY, tile, crop) {
        // Check energy
        if (this.energy < 5) {
            this.showToast("Too tired! Sleep to restore energy.");
            Audio.play('error');
            return;
        }

        switch(item.type) {
            case 'tool':
                this.useTool(item, tileX, tileY, tile, crop);
                break;
            case 'seed':
                this.plantSeed(item, tileX, tileY, tile);
                break;
            case 'placeable':
                this.placeItem(item, tileX, tileY, tile);
                break;
        }
    },

    placeItem(item, tileX, tileY, tile) {
        // Can only place on grass or tilled soil
        if (tile !== TILES.GRASS && tile !== TILES.TILLED && tile !== TILES.FLOWERS) {
            this.showToast("Can't place that here!");
            Audio.play('error');
            return;
        }

        if (item.id === 'sprinkler') {
            this.world[tileY][tileX] = TILES.SPRINKLER;
            this.sprinklers.push({ x: tileX, y: tileY });
            this.removeFromInventory(item);
            this.energy -= 3;
            Audio.play('plant');
            this.showToast('Placed sprinkler! It will water nearby crops each day.');
            // Sprinkler achievement
            if (this.sprinklers.length >= 5) this.unlockAchievement('sprinkler_master');
        } else if (item.id === 'scarecrow') {
            // Scarecrow just prevents crows (visual mostly for now)
            this.showToast('Scarecrow placed! Crows will stay away.');
            this.removeFromInventory(item);
            this.energy -= 3;
            Audio.play('plant');
        }
    },

    useTool(tool, tileX, tileY, tile, crop) {
        switch(tool.id) {
            case 'hoe':
                // Till grass into farmland
                if (tile === TILES.GRASS || tile === TILES.FLOWERS) {
                    this.world[tileY][tileX] = TILES.TILLED;
                    this.energy -= Math.ceil(5 * this.getToolEnergyMultiplier('hoe'));
                    Audio.play('hoe');
                    this.showToast('Tilled the soil!');
                    this.completeTutorialAction('tilled');
                } else if (tile === TILES.TILLED || tile === TILES.WATERED) {
                    this.showToast('Already tilled!');
                } else {
                    this.showToast("Can't till that!");
                    Audio.play('error');
                }
                break;

            case 'watering_can':
                // Water tilled soil or crops
                if (tile === TILES.TILLED) {
                    this.world[tileY][tileX] = TILES.WATERED;
                    this.energy -= Math.ceil(3 * this.getToolEnergyMultiplier('watering_can'));
                    Audio.play('water');
                    // Mark crop as watered if there's one there
                    if (crop) {
                        crop.watered = true;
                        this.showToast('Watered the crop!');
                    } else {
                        this.showToast('Watered the soil!');
                    }
                } else if (tile === TILES.WATERED) {
                    this.showToast('Already watered!');
                } else {
                    this.showToast("Can't water that!");
                    Audio.play('error');
                }
                break;

            case 'pickaxe':
                // Break rocks
                if (tile === TILES.STONE) {
                    this.world[tileY][tileX] = TILES.GRASS;
                    this.clearedResources.push({ x: tileX, y: tileY, type: TILES.STONE, respawnDay: this.day + 7 });
                    this.energy -= Math.ceil(8 * this.getToolEnergyMultiplier('pickaxe'));
                    // Apply mining skill bonus + tool yield bonus
                    const stoneBase = 1 + Math.floor(Math.random() * 2);
                    const stoneYield = Math.floor(stoneBase * this.getSkillBonus('mining') * this.getToolYieldMultiplier('pickaxe'));
                    this.addToInventory(ITEMS.STONE, stoneYield);
                    this.addSkillXP('mining', 5);
                    // Track lifetime stats for achievement
                    this.lifetimeStats.stoneGathered += stoneYield;
                    if (this.lifetimeStats.stoneGathered >= 50) this.unlockAchievement('rock_collector');
                    Audio.play('pickup');
                    this.showToast(`Got ${stoneYield} stone! (+5 Mining XP)`);
                } else {
                    this.showToast("Can't mine that!");
                    Audio.play('error');
                }
                break;

            case 'axe':
                // Chop wood
                if (tile === TILES.WOOD) {
                    this.world[tileY][tileX] = TILES.GRASS;
                    this.clearedResources.push({ x: tileX, y: tileY, type: TILES.WOOD, respawnDay: this.day + 7 });
                    this.energy -= Math.ceil(8 * this.getToolEnergyMultiplier('axe'));
                    // Apply mining skill bonus + tool yield bonus
                    const woodBase = 2 + Math.floor(Math.random() * 2);
                    const woodYield = Math.floor(woodBase * this.getSkillBonus('mining') * this.getToolYieldMultiplier('axe'));
                    this.addToInventory(ITEMS.WOOD, woodYield);
                    this.addSkillXP('mining', 5);
                    // Track lifetime stats for achievement
                    this.lifetimeStats.woodGathered += woodYield;
                    if (this.lifetimeStats.woodGathered >= 50) this.unlockAchievement('lumberjack');
                    Audio.play('pickup');
                    this.showToast(`Got ${woodYield} wood! (+5 Mining XP)`);
                } else {
                    this.showToast("Can't chop that!");
                    Audio.play('error');
                }
                break;

            case 'fishing_rod':
                // Fish in water
                if (tile === TILES.WATER) {
                    this.startFishing(tileX, tileY);
                } else {
                    this.showToast("Need to face water to fish!");
                    Audio.play('error');
                }
                break;
        }
    },

    startFishing(waterX, waterY) {
        if (this.fishing.active) {
            // Already fishing - check if it's a bite
            if (this.fishing.phase === 'bite') {
                this.catchFish();
            }
            return;
        }

        this.fishing.active = true;
        this.fishing.phase = 'casting';
        this.fishing.timer = 30; // Cast animation frames
        this.fishing.waterX = waterX;
        this.fishing.waterY = waterY;
        this.energy -= Math.ceil(3 * this.getToolEnergyMultiplier('fishing_rod'));
        Audio.play('cast');
        this.showToast('Casting...');
    },

    updateFishing() {
        if (!this.fishing.active) return;

        this.fishing.timer--;

        switch (this.fishing.phase) {
            case 'casting':
                if (this.fishing.timer <= 0) {
                    this.fishing.phase = 'waiting';
                    this.fishing.timer = 120 + Math.random() * 240; // 2-6 seconds wait
                    Audio.play('splash');
                    this.showToast('Waiting for a bite...');
                }
                break;

            case 'waiting':
                if (this.fishing.timer <= 0) {
                    // Fish bites!
                    this.fishing.phase = 'bite';
                    this.fishing.biteWindow = 60; // 1 second to react
                    this.selectRandomFish();
                    Audio.play('bite');
                    this.showToast('! ! ! FISH ON ! ! !');
                }
                break;

            case 'bite':
                this.fishing.biteWindow--;
                if (this.fishing.biteWindow <= 0) {
                    // Missed the fish
                    this.fishing.active = false;
                    this.fishing.phase = 'idle';
                    this.showToast('The fish got away...');
                }
                break;
        }
    },

    selectRandomFish() {
        const fishItems = Object.values(ITEMS).filter(i => i.type === 'fish' || i.type === 'junk');
        const roll = Math.random();
        let cumulative = 0;

        for (const fish of fishItems) {
            cumulative += fish.rarity;
            if (roll < cumulative) {
                this.fishing.targetFish = fish;
                return;
            }
        }
        // Default to bass
        this.fishing.targetFish = ITEMS.BASS;
    },

    catchFish() {
        const fish = this.fishing.targetFish;
        this.fishing.active = false;
        this.fishing.phase = 'idle';

        if (fish) {
            this.addToInventory(fish, 1);
            Audio.play('catch');
            this.completeTutorialAction('caught_fish');
            this.unlockAchievement('first_fish');

            // Gain fishing XP (more for rare fish)
            const xpGain = fish.type === 'junk' ? 2 : Math.round(fish.sellPrice / 10);
            this.addSkillXP('fishing', xpGain);

            if (fish.type === 'junk') {
                this.showToast(`Caught: ${fish.emoji} ${fish.name}... (+${xpGain} Fishing XP)`);
            } else if (fish.id === 'golden_fish') {
                this.showToast(`WOW! ${fish.emoji} A GOLDEN FISH! (+${xpGain} Fishing XP)`);
                this.unlockAchievement('golden_catch');
            } else {
                this.showToast(`Caught: ${fish.emoji} ${fish.name}! (+${xpGain} Fishing XP)`);
            }
        }
    },

    plantSeed(seedItem, tileX, tileY, tile) {
        // Check if there's already a crop here
        const existingCrop = this.crops.find(c => c.x === tileX && c.y === tileY);
        if (existingCrop) {
            this.showToast('Already planted here!');
            Audio.play('error');
            return;
        }

        // Check season restrictions
        if (seedItem.seasons && !seedItem.seasons.includes(this.season)) {
            this.showToast(`${seedItem.name} can't grow in ${this.season}!`);
            Audio.play('error');
            return;
        }

        // Can only plant on tilled or watered soil
        if (tile !== TILES.TILLED && tile !== TILES.WATERED) {
            this.showToast('Till the soil first with a hoe!');
            Audio.play('error');
            return;
        }

        // Plant the seed
        this.crops.push({
            x: tileX,
            y: tileY,
            type: seedItem.crop,
            age: 0,
            watered: tile === TILES.WATERED
        });

        // Remove seed from inventory
        const slot = this.inventory[this.selectedSlot];
        slot.count--;
        if (slot.count <= 0) {
            this.inventory[this.selectedSlot] = null;
        }
        this.updateInventoryUI();

        this.energy -= 2;
        Audio.play('plant');
        this.showToast(`Planted ${seedItem.crop} seeds!`);
    },

    harvestCrop(crop) {
        // Find the crop item
        const cropItem = Object.values(ITEMS).find(i => i.id === crop.type);
        if (!cropItem) return;

        // Add to inventory with farming skill bonus
        const baseYield = 1 + Math.floor(Math.random() * 2);
        const bonusYield = Math.floor(baseYield * this.getSkillBonus('farming'));
        this.addToInventory(cropItem, bonusYield);

        // Remove crop from list
        this.crops = this.crops.filter(c => c !== crop);

        // Reset tile to tilled
        this.world[crop.y][crop.x] = TILES.TILLED;

        // Gain farming XP
        this.addSkillXP('farming', 10);

        this.energy -= 2;
        Audio.play('harvest');
        this.showToast(`Harvested ${cropItem.name}! (+10 Farming XP)`);
        this.unlockAchievement('first_crop');
    },

    addToInventory(item, count = 1) {
        // Try to stack with existing
        for (let slot of this.inventory) {
            if (slot && slot.item.id === item.id) {
                slot.count += count;
                this.updateInventoryUI();
                return;
            }
        }
        // Find empty slot
        for (let i = 0; i < this.inventory.length; i++) {
            if (!this.inventory[i]) {
                this.inventory[i] = { item, count };
                this.updateInventoryUI();
                return;
            }
        }
        this.showToast('Inventory full!');
    },

    selectSlot(index) {
        this.selectedSlot = index;
        const slots = document.querySelectorAll('.inv-slot');
        slots.forEach((s, i) => s.classList.toggle('selected', i === index));
    },

    updateInventoryUI() {
        const slots = document.querySelectorAll('.inv-slot');
        slots.forEach((slot, i) => {
            const inv = this.inventory[i];
            const keySpan = slot.querySelector('.key');
            const keyNum = keySpan ? keySpan.outerHTML : '';
            if (inv) {
                const countHtml = inv.count > 1 ? `<span class="count">${inv.count}</span>` : '';
                slot.innerHTML = keyNum + inv.item.emoji + countHtml;
            } else {
                slot.innerHTML = keyNum;
            }
        });
    },

    showItemInfo() {
        const selectedItem = this.inventory[this.selectedSlot];
        if (!selectedItem) {
            this.showToast('No item selected');
            return;
        }
        const item = selectedItem.item;
        let info = `${item.emoji} ${item.name}`;
        if (item.desc) info += ` - ${item.desc}`;
        if (item.sellPrice) info += ` (Sells: $${item.sellPrice})`;
        this.showToast(info);
    },

    showNPCDialog(npc) {
        const dialog = npc.getDialog(this.day);
        this.completeTutorialAction('talked_npc');

        // Track NPCs talked to for achievement
        if (!this.npcsTalkedTo.includes(npc.type)) {
            this.npcsTalkedTo.push(npc.type);
        }

        let html = `<strong>${npc.sprite} ${npc.name}</strong><br><br>`;
        html += `"${dialog}"`;

        let options = '';

        // If shopkeeper, offer to shop
        if (npc.type === 'shopkeeper') {
            options += `<button onclick="Game.closeDialog(); Game.showMarketDialog();">Shop</button>`;
        }

        // If we have something to gift
        const giftableItem = this.inventory.find(slot => {
            if (!slot) return false;
            return Object.keys(npc.data.gifts).includes(slot.item.id);
        });

        if (giftableItem) {
            options += `<button onclick="Game.giftToNPC('${npc.type}', '${giftableItem.item.id}')">
                Give ${giftableItem.item.emoji} ${giftableItem.item.name}
            </button>`;
        }

        options += `<button onclick="Game.closeDialog()">Goodbye</button>`;
        this.showDialog(html, options);
    },

    giftToNPC(npcType, itemId) {
        const npc = this.npcs.find(n => n.type === npcType);
        if (!npc) return;

        // Find and remove item from inventory
        const slotIdx = this.inventory.findIndex(s => s && s.item.id === itemId);
        if (slotIdx === -1) return;

        const slot = this.inventory[slotIdx];
        slot.count--;
        if (slot.count <= 0) {
            this.inventory[slotIdx] = null;
        }
        this.updateInventoryUI();

        // Show gift response
        const response = npc.data.gifts[itemId] || "Thank you!";
        let html = `<strong>${npc.sprite} ${npc.name}</strong><br><br>`;
        html += `"${response}"`;

        Audio.play('sell');
        this.showDialog(html, `<button onclick="Game.closeDialog()">You're welcome!</button>`);
    },

    showShippingBinDialog() {
        let html = '<strong>üì¶ Shipping Bin</strong><br><br>';
        html += 'Items placed here sell automatically at end of day!<br><br>';

        if (this.shippingBin.length > 0) {
            const total = this.shippingBin.reduce((sum, item) => sum + (item.item.sellPrice || 0) * item.count, 0);
            html += `<b>Today's shipment:</b><br>`;
            this.shippingBin.forEach(s => {
                html += `${s.item.emoji} ${s.item.name} x${s.count} ($${s.item.sellPrice * s.count})<br>`;
            });
            html += `<br><b>Total value: $${total}</b>`;
        } else {
            html += '<em>Bin is empty</em>';
        }

        let options = '';

        // Find sellable items in inventory
        const sellables = this.inventory.filter(s => s && s.item.sellPrice);
        if (sellables.length > 0) {
            options += `<button onclick="Game.showAddToShipmentDialog()">Add Items</button>`;
        }

        options += `<button onclick="Game.closeDialog()">Close</button>`;
        this.showDialog(html, options);
    },

    showAddToShipmentDialog() {
        let html = '<strong>Add to Shipment</strong><br><br>';
        let options = '';

        const sellables = this.inventory.filter(s => s && s.item.sellPrice);
        sellables.forEach(slot => {
            const idx = this.inventory.indexOf(slot);
            options += `<button onclick="Game.addToShipment(${idx})">
                ${slot.item.emoji} ${slot.item.name} x${slot.count} ($${slot.item.sellPrice * slot.count})
            </button>`;
        });

        options += `<button onclick="Game.showShippingBinDialog()">Back</button>`;
        this.showDialog(html, options);
    },

    addToShipment(inventoryIndex) {
        const slot = this.inventory[inventoryIndex];
        if (!slot || !slot.item.sellPrice) return;

        // Add to shipping bin
        const existing = this.shippingBin.find(s => s.item.id === slot.item.id);
        if (existing) {
            existing.count += slot.count;
        } else {
            this.shippingBin.push({ item: slot.item, count: slot.count });
        }

        // Remove from inventory
        this.inventory[inventoryIndex] = null;
        this.updateInventoryUI();

        Audio.play('pickup');
        this.showToast(`Added ${slot.item.name} to shipment!`);
        this.showShippingBinDialog();
    },

    forageBerryBush(tileX, tileY) {
        const key = `${tileX},${tileY}`;
        const cooldown = this.forageCooldowns[key];

        if (cooldown && cooldown > this.day) {
            this.showToast('This bush needs time to regrow...');
            return;
        }

        // Random forage item
        const roll = Math.random();
        let item;
        if (roll < 0.6) {
            item = ITEMS.WILD_BERRIES;
        } else if (roll < 0.9) {
            item = ITEMS.MUSHROOM;
        } else {
            item = ITEMS.WILD_HONEY;
        }

        // Apply foraging skill bonus to quantity
        const baseQty = 1 + Math.floor(Math.random() * 2);
        const bonusQty = Math.floor(baseQty * this.getSkillBonus('foraging'));
        this.addToInventory(item, bonusQty);

        // Track lifetime stats for achievement
        this.lifetimeStats.itemsForaged += bonusQty;
        if (this.lifetimeStats.itemsForaged >= 10) this.unlockAchievement('forager');

        // Gain foraging XP
        this.addSkillXP('foraging', 8);

        Audio.play('harvest');
        this.showToast(`Found ${item.emoji} ${item.name} x${bonusQty}! (+8 Foraging XP)`);

        // Set cooldown for 3 days
        this.forageCooldowns[key] = this.day + 3;
    },

    showMarketDialog() {
        this.completeTutorialAction('visited_market');
        let html = '<strong>Market Stall</strong><br><br>';
        html += 'What would you like to do?';

        let options = '';
        options += `<button onclick="Game.showBuyAnimalsDialog()">Buy Animals</button>`;
        options += `<button onclick="Game.showBuySeedsDialog()">Buy Seeds</button>`;

        // Sell options - check if we have sellable items
        const sellableItems = this.inventory.filter(s => s && s.item.sellPrice);
        const matureAnimals = this.animals.filter(a => a.age >= a.maturityAge);

        if (sellableItems.length > 0) {
            options += `<button onclick="Game.showSellCropsDialog()">Sell Crops/Items</button>`;
        }
        if (matureAnimals.length > 0) {
            options += `<button onclick="Game.showSellDialog()">Sell Animals (${matureAnimals.length})</button>`;
        }

        options += `<button onclick="Game.closeDialog()">Leave</button>`;

        this.showDialog(html, options);
    },

    showBuyAnimalsDialog() {
        const pigPrice = 200;
        const rabbitPrice = 50;
        const chickenPrice = 25;
        const goosePrice = 75;

        let html = '<strong>Buy Animals</strong><br><br>';
        html += '<span style="color:#666">Animals produce items when fed & happy!</span><br><br>';
        let options = '';

        // Chicken - cheap, lays eggs daily
        if (this.money >= chickenPrice) {
            options += `<button onclick="Game.buyAnimal('chicken')">üêî Chicken - $${chickenPrice}</button>`;
        } else {
            html += `<span style="color:#888">üêî Chicken - $${chickenPrice} (need $${chickenPrice - this.money} more)</span><br>`;
        }
        html += '<span style="font-size:11px;color:#888">Lays eggs daily when adult</span><br><br>';

        // Goose - feather production
        if (this.money >= goosePrice) {
            options += `<button onclick="Game.buyAnimal('goose')">ü¶¢ Goose - $${goosePrice}</button>`;
        } else {
            html += `<span style="color:#888">ü¶¢ Goose - $${goosePrice} (need $${goosePrice - this.money} more)</span><br>`;
        }
        html += '<span style="font-size:11px;color:#888">Produces feathers regularly</span><br><br>';

        // Rabbit - wool production
        if (this.money >= rabbitPrice) {
            options += `<button onclick="Game.buyAnimal('rabbit')">üê∞ Rabbit - $${rabbitPrice}</button>`;
        } else {
            html += `<span style="color:#888">üê∞ Rabbit - $${rabbitPrice} (need $${rabbitPrice - this.money} more)</span><br>`;
        }
        html += '<span style="font-size:11px;color:#888">Produces wool occasionally</span><br><br>';

        // Pig - truffles when happy
        if (this.money >= pigPrice) {
            options += `<button onclick="Game.buyAnimal('pig')">üêñ Pig - $${pigPrice}</button>`;
        } else {
            html += `<span style="color:#888">üêñ Pig - $${pigPrice} (need $${pigPrice - this.money} more)</span><br>`;
        }
        html += '<span style="font-size:11px;color:#888">Finds truffles when happy</span><br><br>';

        options += `<button onclick="Game.showMarketDialog()">Back</button>`;
        this.showDialog(html, options);
    },

    showBuySeedsDialog() {
        let html = `<strong>Buy Seeds</strong><br>`;
        html += `<em>Current season: ${this.season}</em><br><br>`;
        let options = '';

        const seeds = [
            ITEMS.TURNIP_SEEDS, ITEMS.POTATO_SEEDS, ITEMS.CARROT_SEEDS,
            ITEMS.TOMATO_SEEDS, ITEMS.CORN_SEEDS, ITEMS.PEPPER_SEEDS,
            ITEMS.PUMPKIN_SEEDS
        ];

        seeds.forEach(seed => {
            const inSeason = seed.seasons && seed.seasons.includes(this.season);
            const seasonIcon = inSeason ? '‚úì' : '‚úó';
            const seasonColor = inSeason ? '#4ade80' : '#888';

            if (this.money >= seed.price && inSeason) {
                options += `<button onclick="Game.buySeed('${seed.id}')">
                    ${seed.emoji} ${seed.name} - $${seed.price} (${seed.growDays}d)
                </button>`;
            } else if (!inSeason) {
                html += `<span style="color:${seasonColor}">${seasonIcon} ${seed.emoji} ${seed.name} - Out of season (${seed.seasons.join('/')})</span><br>`;
            } else {
                html += `<span style="color:#888">${seed.emoji} ${seed.name} - $${seed.price} (need $${seed.price - this.money} more)</span><br>`;
            }
        });

        options += `<button onclick="Game.showMarketDialog()">Back</button>`;
        this.showDialog(html, options);
    },

    buySeed(seedId) {
        const seed = Object.values(ITEMS).find(i => i.id === seedId);
        if (!seed || this.money < seed.price) {
            this.showToast("Can't afford that!");
            return;
        }

        this.money -= seed.price;
        this.addToInventory(seed, 5);
        Audio.play('sell');
        this.showToast(`Bought 5 ${seed.name}!`);
        this.showBuySeedsDialog(); // Stay in menu
    },

    showSellCropsDialog() {
        let html = '<strong>Sell Crops & Items</strong><br><br>';
        let options = '';

        const sellableItems = this.inventory.filter(s => s && s.item.sellPrice);
        sellableItems.forEach((slot, idx) => {
            const total = slot.item.sellPrice * slot.count;
            const invIdx = this.inventory.indexOf(slot);
            options += `<button onclick="Game.sellItem(${invIdx})">
                ${slot.item.emoji} ${slot.item.name} x${slot.count} - $${total}
            </button>`;
        });

        if (sellableItems.length === 0) {
            html += 'No items to sell!<br>';
        }

        options += `<button onclick="Game.showMarketDialog()">Back</button>`;
        this.showDialog(html, options);
    },

    sellItem(inventoryIndex) {
        const slot = this.inventory[inventoryIndex];
        if (!slot || !slot.item.sellPrice) return;

        const total = slot.item.sellPrice * slot.count;
        this.money += total;
        this.inventory[inventoryIndex] = null;
        this.updateInventoryUI();

        Audio.play('sell');
        this.showToast(`Sold ${slot.item.name} for $${total}!`);
        this.unlockAchievement('first_sale');
        this.showSellCropsDialog();
    },

    showSellDialog() {
        const mature = this.animals.filter(a => a.age >= a.maturityAge);

        let html = '<strong>Sell Animals</strong><br><br>';
        let options = '';

        mature.forEach(a => {
            html += `${a.sprite} ${a.name}: ${Math.round(a.weight)} lbs - $${a.value}<br>`;
            options += `<button onclick="Game.sellAnimal('${a.id}')">Sell ${a.name} ($${a.value})</button>`;
        });

        options += `<button onclick="Game.showMarketDialog()">Back</button>`;

        this.showDialog(html, options);
    },

    showAnimalDialog(animal) {
        let html = `<strong>${animal.sprite} ${animal.name}</strong><br><br>`;
        html += `Type: ${animal.type.charAt(0).toUpperCase() + animal.type.slice(1)}<br>`;
        html += `Age: ${animal.age} days<br>`;
        html += `Weight: ${Math.round(animal.weight * 10) / 10} lbs<br>`;
        html += `Health: ${animal.health}%<br>`;
        html += `Happiness: ${animal.happiness}%<br>`;
        html += `Hunger: ${animal.hunger > 50 ? 'üçñ Hungry!' : 'Fed'}<br>`;
        html += `<br>Value: $${animal.value}`;
        if (animal.age < animal.maturityAge) {
            html += ` (mature in ${animal.maturityAge - animal.age} days)`;
        }

        // Show product status
        if (animal.hasProduct) {
            const productName = animal.type === 'chicken' ? 'ü•ö Egg' : (animal.type === 'rabbit' ? 'üß∂ Wool' : 'üçÑ Truffle');
            html += `<br><br><span style="color:#4ade80">‚ú® Has ${productName} ready!</span>`;
        } else if (animal.age >= animal.maturityAge) {
            if (animal.hunger >= 50) {
                html += `<br><br><span style="color:#666">Feed to produce items</span>`;
            } else if (animal.happiness <= 30) {
                html += `<br><br><span style="color:#666">Pet to increase happiness</span>`;
            } else {
                html += `<br><br><span style="color:#666">Will produce tomorrow</span>`;
            }
        }

        let options = '';
        if (animal.hasProduct) {
            options += `<button onclick="Game.collectAnimalProduct('${animal.id}')">Collect Product</button>`;
        }
        options += `<button onclick="Game.petAnimal('${animal.id}')">Pet ${animal.name}</button>`;
        options += `<button onclick="Game.closeDialog()">Close</button>`;

        this.showDialog(html, options);
    },

    collectAnimalProduct(id) {
        const animal = this.animals.find(a => a.id === id);
        if (!animal || !animal.hasProduct) {
            this.showToast('No product to collect!');
            return;
        }

        const product = animal.collectProduct();
        if (product) {
            this.addToInventory(product, 1);
            Audio.play('harvest');
            this.showToast(`Collected ${product.emoji} ${product.name} from ${animal.name}!`);

            // Track lifetime stats and check achievements
            if (product.id === 'egg') {
                this.lifetimeStats.eggsCollected++;
                if (this.lifetimeStats.eggsCollected >= 10) this.unlockAchievement('egg_collector');
            } else if (product.id === 'feather') {
                this.lifetimeStats.feathersCollected++;
                if (this.lifetimeStats.feathersCollected >= 10) this.unlockAchievement('feather_collector');
            } else if (product.id === 'wool') {
                this.lifetimeStats.woolCollected++;
                if (this.lifetimeStats.woolCollected >= 10) this.unlockAchievement('wool_collector');
            } else if (product.id === 'truffle') {
                this.lifetimeStats.trufflesFound++;
                this.unlockAchievement('truffle_finder');
            }

            this.showAnimalDialog(animal); // Refresh dialog
        }
    },

    showBarnDialog() {
        const pigs = this.animals.filter(a => a.type === 'pig');
        let html = '<strong>üè† Pig Barn</strong><br><br>';
        html += `Pigs: ${pigs.length}<br>`;
        if (pigs.length > 0) {
            const totalWeight = pigs.reduce((sum, p) => sum + p.weight, 0);
            const avgHealth = Math.round(pigs.reduce((sum, p) => sum + p.health, 0) / pigs.length);
            html += `Total Weight: ${Math.round(totalWeight)} lbs<br>`;
            html += `Avg Health: ${avgHealth}%<br>`;
        }

        this.showDialog(html, `<button onclick="Game.closeDialog()">Close</button>`);
    },

    showHouseDialog() {
        let html = '<strong>üè° Farmhouse</strong><br><br>';
        html += `Money: $${this.money}<br>`;
        html += `Animals: ${this.animals.length}<br>`;
        html += `Day ${this.day}, ${this.season} Year ${this.year}<br>`;
        html += '<br><em>Time passes as you explore the farm.</em>';

        let options = `<button onclick="Game.sleep()">Sleep (Skip to next day)</button>`;
        options += `<button onclick="Game.saveGame()">Save Game</button>`;
        options += `<button onclick="Game.closeDialog()">Close</button>`;

        this.showDialog(html, options);
    },

    buyAnimal(type) {
        const prices = { pig: 200, rabbit: 50, chicken: 25, goose: 75 };
        const price = prices[type] || 50;
        if (this.money < price) {
            this.showToast("Can't afford that!");
            return;
        }

        this.money -= price;

        // Spawn in pasture
        const x = (21 + Math.random() * 3) * TILE_SIZE;
        const y = (11 + Math.random() * 2) * TILE_SIZE;
        const animal = new Animal(x, y, type);
        this.animals.push(animal);

        this.showToast(`Welcome ${animal.name} to the farm!`);
        this.unlockAchievement('first_animal');

        // Check animal count achievement
        if (this.animals.length >= 10) this.unlockAchievement('animal_rancher');

        // Check for full menagerie (all 4 animal types)
        const animalTypes = new Set(this.animals.map(a => a.type));
        if (animalTypes.size >= 4) this.unlockAchievement('full_menagerie');

        this.closeDialog();
    },

    sellAnimal(id) {
        const idx = this.animals.findIndex(a => a.id === id);
        if (idx === -1) return;

        const animal = this.animals[idx];
        this.money += animal.value;
        this.animals.splice(idx, 1);

        this.showToast(`Sold ${animal.name} for $${animal.value}!`);
        this.unlockAchievement('first_sale');
        this.closeDialog();
    },

    petAnimal(id) {
        const animal = this.animals.find(a => a.id === id);
        if (animal) {
            animal.happiness = Math.min(100, animal.happiness + 5);
            this.showToast(`${animal.name} seems happy!`);
        }
        this.closeDialog();
    },

    feedAnimals() {
        const hungry = this.animals.filter(a => a.hunger > 0);
        if (hungry.length === 0) {
            this.showToast('No animals need feeding!');
            return;
        }

        const feedCosts = { pig: 5, rabbit: 1, chicken: 1, goose: 2 };
        const cost = hungry.reduce((sum, a) => sum + (feedCosts[a.type] || 1), 0);

        if (this.money < cost) {
            this.showToast(`Need $${cost} to feed all animals!`);
            return;
        }

        this.money -= cost;
        hungry.forEach(a => a.feed());
        this.showToast(`Fed ${hungry.length} animals for $${cost}!`);
    },

    sleep() {
        this.dayTimer = this.DAY_LENGTH - 1;
        this.showToast('Slept through the night...');
        this.completeTutorialAction('slept');
        this.closeDialog();
    },

    saveGame() {
        const save = {
            version: '2.0.0',
            money: this.money,
            day: this.day,
            season: this.season,
            year: this.year,
            energy: this.energy,
            timeOfDay: this.timeOfDay,
            dayTimer: this.dayTimer,
            animals: this.animals.map(a => ({
                type: a.type,
                x: a.x,
                y: a.y,
                age: a.age,
                health: a.health,
                happiness: a.happiness,
                hunger: a.hunger,
                weight: a.weight,
                name: a.name,
                genetics: a.genetics,
                hasProduct: a.hasProduct,
                productCooldown: a.productCooldown
            })),
            crops: this.crops.map(c => ({
                x: c.x,
                y: c.y,
                type: c.type,
                age: c.age,
                watered: c.watered
            })),
            inventory: this.inventory.map(slot => slot ? {
                itemId: slot.item.id,
                count: slot.count
            } : null),
            sprinklers: this.sprinklers,
            shippingBin: this.shippingBin.map(s => ({
                itemId: s.item.id,
                count: s.count
            })),
            clearedResources: this.clearedResources,
            forageCooldowns: this.forageCooldowns,
            achievements: this.achievements,
            npcsTalkedTo: this.npcsTalkedTo,
            skills: this.skills,
            toolUpgrades: this.toolUpgrades,
            lifetimeStats: this.lifetimeStats,
            playerX: this.player.x,
            playerY: this.player.y,
            musicEnabled: Audio.musicEnabled
        };
        localStorage.setItem('texasfarms_save', JSON.stringify(save));
        this.showToast('Game saved!');
    },

    loadGame() {
        const saveData = localStorage.getItem('texasfarms_save');
        if (!saveData) {
            this.showToast('No save found!');
            return false;
        }

        try {
            const save = JSON.parse(saveData);

            // Start with fresh world
            this.world = generateWorld();
            this.player = new Player(save.playerX || 10 * TILE_SIZE, save.playerY || 10 * TILE_SIZE);

            // Restore basic stats
            this.money = save.money || 500;
            this.day = save.day || 1;
            this.season = save.season || 'Spring';
            this.year = save.year || 1;
            this.energy = save.energy || 100;
            this.timeOfDay = save.timeOfDay || 0.25;
            this.dayTimer = save.dayTimer || 0;

            // Restore animals
            this.animals = (save.animals || []).map(a => {
                const animal = new Animal(a.x, a.y, a.type);
                animal.age = a.age;
                animal.health = a.health;
                animal.happiness = a.happiness;
                animal.hunger = a.hunger;
                animal.weight = a.weight;
                animal.name = a.name;
                animal.genetics = a.genetics;
                animal.hasProduct = a.hasProduct || false;
                animal.productCooldown = a.productCooldown || 0;
                return animal;
            });

            // Restore crops
            this.crops = save.crops || [];
            this.crops.forEach(crop => {
                this.world[crop.y][crop.x] = crop.watered ? TILES.WATERED : TILES.TILLED;
            });

            // Restore inventory
            this.inventory = (save.inventory || []).map(slot => {
                if (!slot) return null;
                const item = Object.values(ITEMS).find(i => i.id === slot.itemId);
                return item ? { item, count: slot.count } : null;
            });
            while (this.inventory.length < 8) this.inventory.push(null);

            // Restore sprinklers
            this.sprinklers = save.sprinklers || [];
            this.sprinklers.forEach(s => {
                this.world[s.y][s.x] = TILES.SPRINKLER;
            });

            // Restore shipping bin
            this.shippingBin = (save.shippingBin || []).map(s => {
                const item = Object.values(ITEMS).find(i => i.id === s.itemId);
                return item ? { item, count: s.count } : null;
            }).filter(s => s);

            // Restore misc state
            this.clearedResources = save.clearedResources || [];
            this.forageCooldowns = save.forageCooldowns || {};
            this.achievements = save.achievements || [];
            this.npcsTalkedTo = save.npcsTalkedTo || [];

            // Restore skills
            if (save.skills) {
                this.skills = save.skills;
            }

            // Restore tool upgrades
            if (save.toolUpgrades) {
                this.toolUpgrades = save.toolUpgrades;
            }

            // Restore lifetime stats (merge with defaults for backwards compatibility)
            if (save.lifetimeStats) {
                this.lifetimeStats = {
                    stoneGathered: save.lifetimeStats.stoneGathered || 0,
                    woodGathered: save.lifetimeStats.woodGathered || 0,
                    itemsForaged: save.lifetimeStats.itemsForaged || 0,
                    eggsCollected: save.lifetimeStats.eggsCollected || 0,
                    feathersCollected: save.lifetimeStats.feathersCollected || 0,
                    woolCollected: save.lifetimeStats.woolCollected || 0,
                    trufflesFound: save.lifetimeStats.trufflesFound || 0
                };
            }

            // Create NPCs
            this.npcs = [
                new NPC(11 * TILE_SIZE, 16 * TILE_SIZE, 'shopkeeper'),
                new NPC(9 * TILE_SIZE, 8 * TILE_SIZE, 'mayor'),
                new NPC(14 * TILE_SIZE, 12 * TILE_SIZE, 'wanderer'),
            ];

            // Reset fishing state
            this.fishing = {
                active: false,
                phase: 'idle',
                timer: 0,
                biteWindow: 0,
                targetFish: null
            };

            // Disable tutorial for loaded games
            this.tutorial.active = false;

            // Restore music state
            if (save.musicEnabled) {
                Audio.startMusic();
                document.getElementById('music-toggle').textContent = 'üéµ';
            }

            this.updateInventoryUI();
            return true;
        } catch (e) {
            console.error('Failed to load save:', e);
            this.showToast('Save data corrupted!');
            return false;
        }
    },

    hasSaveGame() {
        return localStorage.getItem('texasfarms_save') !== null;
    },

    continueGame() {
        document.getElementById('title-screen').style.display = 'none';
        if (this.loadGame()) {
            this.running = true;
            this.gameLoop();
            this.showToast('Welcome back to Texas Farms!');
        } else {
            this.start(); // Fall back to new game if load fails
        }
    },

    showDialog(text, optionsHTML) {
        document.getElementById('dialog-text').innerHTML = text;
        document.getElementById('dialog-options').innerHTML = optionsHTML;
        document.getElementById('dialog').classList.add('show');
        this.dialogOpen = true;
    },

    closeDialog() {
        document.getElementById('dialog').classList.remove('show');
        this.dialogOpen = false;
    },

    toggleMusic() {
        const enabled = Audio.toggleMusic();
        document.getElementById('music-toggle').textContent = enabled ? 'üéµ' : 'üîá';
        this.showToast(enabled ? 'üéµ Music ON' : 'üîá Music OFF');
    },

    showToast(message) {
        const toast = document.getElementById('toast');
        toast.textContent = message;
        toast.classList.remove('show');
        void toast.offsetWidth; // Trigger reflow
        toast.classList.add('show');
    },

    updateHUD() {
        document.getElementById('money-display').textContent = `$${this.money}`;
        document.getElementById('time-display').textContent = `Day ${this.day}, ${this.season} Y${this.year}`;

        // Show animal count with breakdown
        const animalCounts = {
            chicken: this.animals.filter(a => a.type === 'chicken').length,
            goose: this.animals.filter(a => a.type === 'goose').length,
            rabbit: this.animals.filter(a => a.type === 'rabbit').length,
            pig: this.animals.filter(a => a.type === 'pig').length
        };
        const animalDisplay = [];
        if (animalCounts.chicken) animalDisplay.push(`${animalCounts.chicken}üêî`);
        if (animalCounts.goose) animalDisplay.push(`${animalCounts.goose}ü¶¢`);
        if (animalCounts.rabbit) animalDisplay.push(`${animalCounts.rabbit}üê∞`);
        if (animalCounts.pig) animalDisplay.push(`${animalCounts.pig}üêñ`);
        document.getElementById('animal-count').textContent = animalDisplay.length > 0
            ? animalDisplay.join(' ')
            : '0 animals';

        // Weather icon
        const weatherIcons = {
            sunny: '‚òÄÔ∏è',
            cloudy: '‚õÖ',
            rainy: 'üåßÔ∏è',
            stormy: '‚õàÔ∏è'
        };
        document.getElementById('weather-display').textContent = weatherIcons[this.weather.type] || '‚òÄÔ∏è';
    },

    render() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw world
        for (let y = 0; y < WORLD_HEIGHT; y++) {
            for (let x = 0; x < WORLD_WIDTH; x++) {
                const tile = this.world[y][x];
                const screenX = x * TILE_SIZE - this.camera.x;
                const screenY = y * TILE_SIZE - this.camera.y;

                // Skip if off screen
                if (screenX < -TILE_SIZE || screenX > this.canvas.width ||
                    screenY < -TILE_SIZE || screenY > this.canvas.height) continue;

                // Draw base tile
                ctx.fillStyle = TILE_COLORS[tile] || '#4a7c59';
                ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

                // Draw tile decorations
                ctx.font = `${TILE_SIZE - 8}px serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (tile === TILES.TREE) {
                    ctx.fillText('üå≤', screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
                } else if (tile === TILES.FLOWERS) {
                    ctx.fillText('üå∏', screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
                } else if (tile === TILES.TROUGH) {
                    ctx.fillStyle = '#555';
                    ctx.fillRect(screenX + 4, screenY + TILE_SIZE - 16, TILE_SIZE - 8, 12);
                } else if (tile === TILES.MARKET_STALL) {
                    ctx.fillText('üè™', screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
                } else if (tile === TILES.HAY) {
                    ctx.fillText('üåæ', screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
                } else if (tile === TILES.STONE) {
                    ctx.fillText('ü™®', screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
                } else if (tile === TILES.WOOD) {
                    ctx.fillText('ü™µ', screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
                } else if (tile === TILES.TILLED) {
                    // Draw tilled soil pattern
                    ctx.fillStyle = '#5a3d1a';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(screenX + 8 + i * 12, screenY + 10, 8, 28);
                    }
                } else if (tile === TILES.WATERED) {
                    // Draw watered soil (darker with shine)
                    ctx.fillStyle = '#3a2d15';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(screenX + 8 + i * 12, screenY + 10, 8, 28);
                    }
                    ctx.fillStyle = 'rgba(100,150,255,0.3)';
                    ctx.fillRect(screenX + 4, screenY + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                } else if (tile === TILES.SHIPPING_BIN) {
                    ctx.fillText('üì¶', screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
                } else if (tile === TILES.BERRY_BUSH) {
                    // Check if on cooldown
                    const key = `${x},${y}`;
                    const onCooldown = this.forageCooldowns[key] && this.forageCooldowns[key] > this.day;
                    ctx.fillText(onCooldown ? 'üåø' : 'ü´ê', screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
                } else if (tile === TILES.SPRINKLER) {
                    ctx.fillText('üíß', screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);
                }
            }
        }

        // Draw crops
        this.crops.forEach(crop => {
            const screenX = crop.x * TILE_SIZE - this.camera.x;
            const screenY = crop.y * TILE_SIZE - this.camera.y;

            if (screenX < -TILE_SIZE || screenX > this.canvas.width ||
                screenY < -TILE_SIZE || screenY > this.canvas.height) return;

            // Get crop stage
            const stages = CROP_STAGES[crop.type];
            const seedItem = Object.values(ITEMS).find(i => i.crop === crop.type);
            const progress = Math.min(crop.age / seedItem.growDays, 1);
            const stageIdx = Math.min(Math.floor(progress * stages.length), stages.length - 1);
            const sprite = stages[stageIdx];

            ctx.font = `${TILE_SIZE - 12}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(sprite, screenX + TILE_SIZE/2, screenY + TILE_SIZE/2);

            // Draw "ready" sparkle
            if (crop.age >= seedItem.growDays) {
                ctx.font = '16px serif';
                ctx.fillText('‚ú®', screenX + TILE_SIZE - 10, screenY + 10);
            }

            // Draw water droplet if not watered today
            if (!crop.watered && crop.age < seedItem.growDays) {
                ctx.font = '14px serif';
                ctx.fillText('üíß', screenX + 8, screenY + 8);
            }
        });

        // Draw hover tile indicator
        if (this.hoverTile) {
            const hoverX = this.hoverTile.x * TILE_SIZE - this.camera.x;
            const hoverY = this.hoverTile.y * TILE_SIZE - this.camera.y;
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 3;
            ctx.strokeRect(hoverX + 2, hoverY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
        }

        // Draw animals and NPCs (sorted by Y for depth)
        const entities = [...this.animals, ...this.npcs].sort((a, b) => a.y - b.y);
        entities.forEach(e => e.draw(ctx, this.camera));

        // Draw player
        this.player.draw(ctx, this.camera);

        // Draw fishing visuals
        if (this.fishing.active && this.fishing.waterX !== undefined) {
            const bobberX = this.fishing.waterX * TILE_SIZE - this.camera.x + TILE_SIZE / 2;
            const bobberY = this.fishing.waterY * TILE_SIZE - this.camera.y + TILE_SIZE / 2;
            const playerScreenX = this.player.x - this.camera.x + TILE_SIZE / 2;
            const playerScreenY = this.player.y - this.camera.y + TILE_SIZE / 2;

            // Draw fishing line
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(playerScreenX, playerScreenY - 10);
            ctx.lineTo(bobberX, bobberY);
            ctx.stroke();

            // Draw bobber
            ctx.fillStyle = this.fishing.phase === 'bite' ? '#ff0000' : '#ff6600';
            ctx.beginPath();
            ctx.arc(bobberX, bobberY + (this.fishing.phase === 'bite' ? Math.sin(Date.now() / 50) * 5 : 0), 8, 0, Math.PI * 2);
            ctx.fill();

            // Exclamation when bite
            if (this.fishing.phase === 'bite') {
                ctx.font = 'bold 24px sans-serif';
                ctx.fillStyle = '#ff0000';
                ctx.textAlign = 'center';
                ctx.fillText('!', bobberX, bobberY - 20);
            }
        }

        // Draw interaction hint
        const point = this.player.getInteractionPoint();
        const tileX = Math.floor(point.x / TILE_SIZE);
        const tileY = Math.floor(point.y / TILE_SIZE);

        if (tileX >= 0 && tileX < WORLD_WIDTH && tileY >= 0 && tileY < WORLD_HEIGHT) {
            const tile = this.world[tileY][tileX];
            // Highlight interactable tiles
            const interactable = [TILES.MARKET_STALL, TILES.TROUGH, TILES.DOOR, TILES.GRASS,
                                  TILES.FLOWERS, TILES.TILLED, TILES.WATERED, TILES.STONE, TILES.WOOD];
            if (interactable.includes(tile)) {
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    tileX * TILE_SIZE - this.camera.x + 2,
                    tileY * TILE_SIZE - this.camera.y + 2,
                    TILE_SIZE - 4,
                    TILE_SIZE - 4
                );
            }
        }

        // Check for nearby NPCs and highlight
        const nearbyNPC = this.npcs.find(npc => {
            const nx = Math.floor(npc.x / TILE_SIZE);
            const ny = Math.floor(npc.y / TILE_SIZE);
            return Math.abs(nx - tileX) <= 1 && Math.abs(ny - tileY) <= 1;
        });

        if (nearbyNPC) {
            ctx.strokeStyle = 'rgba(0,255,255,0.6)';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                Math.floor(nearbyNPC.x / TILE_SIZE) * TILE_SIZE - this.camera.x + 2,
                Math.floor(nearbyNPC.y / TILE_SIZE) * TILE_SIZE - this.camera.y + 2,
                TILE_SIZE - 4,
                TILE_SIZE - 4
            );
        }

        // Check for nearby animals and highlight
        const nearbyAnimal = this.animals.find(a => {
            const ax = Math.floor(a.x / TILE_SIZE);
            const ay = Math.floor(a.y / TILE_SIZE);
            return Math.abs(ax - tileX) <= 1 && Math.abs(ay - tileY) <= 1;
        });

        if (nearbyAnimal) {
            ctx.strokeStyle = 'rgba(255,255,0,0.5)';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                Math.floor(nearbyAnimal.x / TILE_SIZE) * TILE_SIZE - this.camera.x + 2,
                Math.floor(nearbyAnimal.y / TILE_SIZE) * TILE_SIZE - this.camera.y + 2,
                TILE_SIZE - 4,
                TILE_SIZE - 4
            );
        }

        // Day/night overlay
        this.renderDayNight(ctx);

        // Weather overlay
        this.renderWeather(ctx);
    },

    renderDayNight(ctx) {
        // timeOfDay: 0 = midnight, 0.25 = 6am, 0.5 = noon, 0.75 = 6pm, 1 = midnight
        let darkness = 0;
        let tint = { r: 0, g: 0, b: 0 };

        if (this.timeOfDay < 0.25) {
            // Night to dawn (midnight to 6am)
            darkness = 0.5 - this.timeOfDay * 2;
            tint = { r: 20, g: 30, b: 60 };
        } else if (this.timeOfDay < 0.35) {
            // Dawn (6am to ~8am) - golden hour
            const t = (this.timeOfDay - 0.25) / 0.1;
            tint = { r: 255 * (1-t), g: 180 * (1-t), b: 100 * (1-t) };
            darkness = 0;
        } else if (this.timeOfDay < 0.7) {
            // Day (8am to 5pm)
            darkness = 0;
        } else if (this.timeOfDay < 0.8) {
            // Sunset (5pm to ~7pm) - golden hour
            const t = (this.timeOfDay - 0.7) / 0.1;
            tint = { r: 255 * t, g: 150 * t, b: 50 * t };
            darkness = t * 0.1;
        } else {
            // Night (7pm to midnight)
            const t = (this.timeOfDay - 0.8) / 0.2;
            darkness = 0.1 + t * 0.4;
            tint = { r: 20, g: 30, b: 60 };
        }

        if (darkness > 0 || tint.r > 0 || tint.g > 0 || tint.b > 0) {
            ctx.fillStyle = `rgba(${tint.r}, ${tint.g}, ${tint.b}, ${Math.max(darkness, 0.1)})`;
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }
    },

    renderWeather(ctx) {
        // Cloud overlay for cloudy/rainy/stormy
        if (this.weather.type !== 'sunny') {
            const alpha = this.weather.type === 'stormy' ? 0.4 : this.weather.type === 'rainy' ? 0.25 : 0.15;
            ctx.fillStyle = `rgba(100, 100, 120, ${alpha})`;
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        // Draw rain particles
        if (this.weather.particles.length > 0) {
            ctx.strokeStyle = this.weather.type === 'stormy' ? 'rgba(200,200,255,0.6)' : 'rgba(150,150,200,0.5)';
            ctx.lineWidth = this.weather.type === 'stormy' ? 2 : 1;
            ctx.beginPath();

            this.weather.particles.forEach(p => {
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(p.x - p.length * 0.3, p.y + p.length);
            });

            ctx.stroke();
        }

        // Lightning flash for storms
        if (this.weather.type === 'stormy' && Math.random() < 0.002) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            Audio.play('error'); // Thunder-like sound
        }
    }
};

// Initialize on load
window.addEventListener('DOMContentLoaded', () => Game.init());
</script>
</body>
</html>
